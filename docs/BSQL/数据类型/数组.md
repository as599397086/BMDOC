## **概要**

多维数组允许您在表中的单个字段中存储大的复合值；它允许您将这样的值分配给PL/pgSQL变量，或者通过过程或函数的形式参数传递它。
您可以从下面的声明中看到，数组中的每个值都是同一数据类型，要么是文本或数字等基本数据类型，要么是用户自定义的标量或复合数据类型（如“row”类型）。
根据定义，数组是一组N维的“单元”。可以将一维数组想象成一行单元格，将二维数组想象成矩形单元格，将三维数组想象成长方体单元格。“N维数组”包括这些和所有其他数组，N称为其维数。

数组中的值由元组的索引值指定，如下所示（对于四维数组）：
arr[13][7][5][17]

索引是所讨论维度上的单元格编号。每个维度上的索引值是连续的，换句话说，不能删除数组中的单元格。这反映了一个事实，即数组是线性化的。然而，单元格中的值可以是NULL的。
针对于上例，最左边的值（示例中为13）是第一维度的索引；最右边的值（本例中为17）是第N维度，即本例中的第四维度的索引。沿着特定维度的第一个单元格的索引的值被称为该维度的下界。如果在创建数组值时不采取任何特殊步骤，则每个维度的下界为1。但是，如果您觉得它很有用，您可以指定任何正整数，或负整数，或零作为指定维度的下界。数组的下限在创建时是固定的，其维度也是固定的。 
相应地，每个维度都有一个上界。这在数组创建时也是固定的。每个维度上的索引值是连续的。每个维度的上界和下界都有一个值，这反映了数组是线性化的。
如果您读取了一个数组边界之外的数组值，默认会得到NULL。但是，如果您试图设置这样一个越界值，那么，因为这是一个隐式的更改数组边界的尝试，您会得到“数组下标超出范围”的错误。
 请注意，通过沿源数组的每个轴指定所需的上下索引值，可以使用单个赋值，创建一个数组，作为数组的所谓“切片”。新数组的维度不能与其源维度不同。您应该指定切片的上下索引值，沿着源数组的每个维度，使其位于该维度的边界内（或最大限度地与该边界重合）。如果指定的切片的下界小于源数组的相应下界，则新的下界被默认地解释为现存的对应源下界，上界也是如此。此方法的语法意味着新数组的下界不可避免地都从1开始。下面是一个使用二维源数组的示例（使用PL/pgSQL语法）：

```
new_arr := source_arr[3:4][7:9];
```

注：一维数组是一种特殊情况，因为在N维形状中，它是唯一的线性的。通过在索引值低于当前下界，或索引值高于当前上界的单元格中设置值，可以隐式增加此类数组的长度。一旦完成了这项操作，就无法减少长度，因为没有对此进行显式操作，也没有对指定单元格进行“取消设置”操作。但是，您可以创建一个切片，以便新数组具有源数组的原始大小。
以下属性决定数组的形状。每一个都可以使用下述专用函数进行查看。第一个形式参数（数据类型为anyarray）是数组。在适当的时候，还有第二个形式参数（数据类型为int），用于指定维度。返回值是一个int值，但有一种情况除外，它的返回值是一个text 值，如下所述。
array_ndims()：返回指定数组的维度。
array_lower()：返回指定维度上的数组的下界。 
array_upper()：返回指定维度上的数组的上界。
array_length()：返回指定维度上的数组的长度。对于特定维度，长度、上界和下界是相互关联的，因此
 "长度" = "上界" - "下界" + 1
cardinality()：返回指定数组中的单元格总数。沿着每个维度的基数和长度是相互关联的，因此：
"cardinality" = "length 1" * "length 2" * ... * "length N"

array_dims()：对于所有维度，在单个文本值中返回与array_lower（）和array_length（）相同信息的文本表示形式。例如，对于三维数组，返回类似[3:4][7:9][2:5]所示的上界和下界。
数组之所以特殊，是因为（与例如decimal和int等数字数据类型，或text和varchar等字符数据类型不同）没有现成的数组数据类型。相反，您可以使用数组类型构造函数来构造所需的数组数据类型。以下是一个示例：

```
create table t1(k int primary key, arr text array[4]);
```

此语法符合SQL标准。请注意，数组是一个保留字。（例如，你不能用这个名称创建一个表。）

以下说明了PostgreSQL标准扩展：

```
create table t2(
  k int primary key,
  one_dimensional_array int[],
  two_dimensional_array int[10][10]);
```

### 原子为Null与所有值为Null的对比
这里是一个示例：

```
create table t(k int primary key, v int[]);
insert into t(k) values(1);
insert into t(k, v) values (2, '{null}'::int[]);
\pset null '<is null>'
select k, v, array_dims(v) as dims from t order by k;
```

显示如下：

```
 k |     v     |   dims
---+-----------+-----------
 1 | <is null> | <is null>
 2 | {NULL}    | [1:1]
```

因为“v”没有约束，所以它可以是NULL，就像它的数据类型是标量一样。对于具有“k=1”的行，情况就是这样。在这里，“v”被称为原子Null。（这个术语通常只在数据类型是复合的时使用，以区分结果与“k=2”行的结果，而其中“v”不是原子Null）。第一行的“v”的数组属性，就像它的维度一样，都是NULL。但对于第二行，它们是有意义的值，而不是NULL。继续看如下示例：

```
update t set v = v||'{null}'::int[] where k = 2;
select k, v, array_dims(v) as dims from t where k = 2;
```

查询显示如下：

```
 k |      v      | dims
---+-------------+-------
 2 | {NULL,NULL} | [1:2]
```

这里，第二行的“v”，虽然不是原子NULL，但其所有值都为NULL。它的维度不能改变，但因为它是一个一维数组，所以它的长度可以扩展，如上所述。这是允许的： 

```
update t set v[0] = 17 where k = 2;
select k, v, array_dims(v) as dims from t where k = 2;
```

查询显示如下：

```
 k |             v             | dims
---+---------------------------+-------
 2 | [0:3]={17,NULL,NULL,NULL} | [0:3]
```

同理，如下也是可以的：

```
update t set v[1] = 42 where k = 1;
select k, v, array_dims(v) as dims from t where k = 1;
```

查询显示如下：

```
 k |  v   | dims
---+------+-------
 1 | {42} | [1:1]
```

### 类型构造
数组并不是类型构造的唯一示例。“row”类型和DOMAIN也是如此，示例如下：

```
create type rec_t as(f1 int, f2 text);
create domain medal_t as text
check(
  length(value) <= 6 and
  value in ('gold', 'silver', 'bronze')
);
create table t3(k int primary key, rec rec_t, medal medal_t);
```

请注意，必须将“row”类型或DOMAIN定义为架构对象。但是，在创建表或编写PL/pgSQL代码时，您可以定义数组的数据类型，如上所示。换句话说，您不能命名构造数组类型。相反，您只能“动态”使用它来定义列、PL/pgSQL变量或PL/pgSQL形式参数的数据类型。

### 数组应用
首先，观察如下示例中，将创建一个带有int[]列的表，并适当地填充二维数组。

```
create table t ( k int primary key, v int[]);
insert into t(k, v) values(1,
   '{
      {11, 12, 13},
      {21, 22, 23}
    }
  '::int[]);
```

接下来，查看插入的值，这里，使用::text，进行类型转换：

```
select v::text from t where k = 1;
```

查询显示如下：

```
            v
-------------------------
 {{11,12,13},{21,22,23}}
```

请注意，除了没有空格之外，与定义时，插入数组的文本内容完全相同。

接下来，检查插入的数组值，是否具有预期的属性：

```
select
  array_ndims(v),
  array_length(v, 1),
  array_length(v, 2),
  array_dims(v)
from t where k = 1;
```

查询显示如下：

```
  array_ndims | array_length | array_length | array_dims
------------+--------------+--------------+------------
              2 |              2 |               3 | [1:2][1:3]
```

array_ndims() 报告数组的维度；
array_length() 报告指定维度的长度（即该维度具有的值的数目）；
array_dims() 作为单个文本值显示相同的信息，就像对每个维度依次使用array_length（）一样。请注意，array_length（）为指定的维度返回一个int值。它的设计基于一条规则，例如二维数组必须是矩形。同样，三维阵列必须是长方体。
请注意，如下是违反规则的示例：

```
insert into t(k, v) values(2,
   '{
      {11, 12, 13},
      {21, 22, 23, 24}
    }
  '::int[]);
```

最后，这个DO块显示了如何将二维数组中的值，可视化为矩形网格。

```
do $body$
declare
  arr constant int[] not null:= '{
      {11, 12, 13, 14},
      {21, 22, 23, 24},
      {31, 32, 33, 34}
    }'::int[];
 
  ndims constant int not null := array_ndims(arr);
  line text;
begin
  if array_ndims(arr) <> 2 then
    raise exception 'This code handles only a two-dimensional array.';
  end if;
 
  declare
    len1 constant int not null := array_length(arr, 1);
    len2 constant int not null := array_length(arr, 2);
  begin
    for row in 1..len1 loop
      line := ' ';
      for col in 1..len2 loop
        line := line||lpad(arr[row][col]::text, 5);
      end loop;
      raise info '%', line;
    end loop;
  end;
end;
$body$;
```

查询显示类似如下：

```
   11   12   13   14
   21   22   23   24
   31   32   33   34
```

这种方法对于具有更高维度的数组，或第二维度较大的二维数组来说并不实用。相反，这里包含的代码仅仅是为了展示如何处理各个元素。隐式声明的FOR循环变量“row”和“col”的名称直观地对应于值在定义数组值的文字中的排列方式。嵌套循环被设计为以所谓的行主顺序访问值（最后一个下标变化最快）。 
例如，当比较相同维度的多维数组的值时，按此顺序访问它们，并以与比较标量值相同的方式成对进行比较。
请注意，在上面的示例中，每个维度中的第一个值的索引值为1。当数组值是使用文本创建的，而对索引值不提及时，就会出现这种情况。下一个示例显示了如何控制每个维度的索引值的起点和终点。 

```
\pset null '<is null>'
with v as (
  select '[2:4][5:8]=
    {
      {25, 26, 27, 28},
      {35, 36, 37, 38},
      {45, 46, 47, 48}
    }'::int[] as arr)
select
  arr[0][0] as "[0][0]",
  arr[2][5] as "[2][5]",
  arr[2][8] as "[2][8]",
  arr[4][5] as "[4][5]",
  arr[4][8] as "[4][8]",
  arr[9][9] as "[9][9]"
from v;
```

在此语法中，[2:4]意味着索引在第一个维度上从2到4；[5:8]意味着在第二维度上从5到8。此例中，选择这些值是仅仅为了说明这一点。当然，您必须为每个维度提供正确数量的值。查询会产生以下结果：

```
  [0][0]   | [2][5] | [2][8] | [4][5] | [4][8] |  [9][9]
-----------+--------+--------+--------+--------+-----------
 <is null> |     25 |     28 |     45 |     48 | <is null>
```

请注意，如果您访问的元素的索引值超出了定义值的范围，那么，如前所述，您会得到NULL。 
数组中的值，在内部，是通过按行主顺序连续排列来存储的。因为每个值都有相同的数据类型，这意味着可以在没有索引支持的情况下，通过计算其偏移量来快速处理感兴趣的值。值本身就可以知道它的维度。这也解释了如何将不同维度的数组存储在单个表列中。即使表示是可变长度的（例如文本值），每一个都知道自己的长度，因此可以计算值边界值。

### 数组应用示例
业余自行车手喜欢使用GPS设备记录他们的行程，然后将记录的数据上传到一个专门用于此目的的互联网网站，这样他们就可以在未来，随时查看自己和其他人的行程。这样的网站可能会使用SQL数据库来存储所有这些行程。
GPS设备可以让骑自行车的人将行程分成连续的间隔，通常称为圈数，这样以后就可以将注意力集中在感兴趣的特定圈数上，比如陡坡。所以每次行程都有一圈，或多圈。一圈通常不超过100公里，通常更像5-10公里。但它可能大到300公里。在良好的条件下，现代设备的分辨率通常只有几步，比如3米。因此，一圈可能有多达100000个GPS数据点，每个数据点都记录时间戳、位置，以及其他相关的瞬时值，例如心率。
这看起来像是一个经典的三表设计，带有外键约束，捕捉一圈的GPS数据点，而这一圈又属于一次行程。数组类型允许属于一圈的所有GPS数据点，记录在“圈”表的单行中，换句话说，其是作为多值字段存储的，例如如下设计：

```
create type gps_data_point_t as (
  ts          timestamp,
  lat         numeric,
  long        numeric,
  alt         numeric,
  cadence     int,
  heart_rate  int
  
  );
create table trips(
  trip_start_ts    timestamp,
  userid           uuid,
  constraint trips_pk primary key (trip_start_ts, userid)
);
create table laps(
  lap_start_ts     timestamp,
  trip_start_ts    timestamp,
  userid           uuid,
  gps_data_points  gps_data_point_t[],
 
  constraint laps_pk primary key (lap_start_ts, trip_start_ts, userid),
 
  constraint laps_fk foreign key (trip_start_ts, userid)
    references trips(trip_start_ts, userid)
    match full on delete cascade on update restrict);
```

注：在PostgreSQL中，任何维度的数组可以容纳的最大值为（2^27-1）（约1.37亿）。如果超过此限制，则会得到一个“54000:数组大小超过允许的最大值（134217727）”的错误。这映射到PL/pgSQL异常“program_limit_exceeded”。在PostgreSQL中，数组的值不是按行存储的。然而，在AiSQL BSQL子系统中，它们是按行存储的，例如，就像json或jsonb值一样。因此，BSQL数组可以容纳的最大值数小于PostgreSQL的限制。此外，实际的BSQL限制取决于具体情况，当超过时，会出现“超时”错误。实验表明，该极限值约为3000万。您可以使用array_fill（）函数对其进行测试。

## **array[]构造函数**

### 用途与用法
array[]值构造函数是一个特殊的变量函数，使用方括号（[]）将实际参数列表括起来。

用途：使用数组的值表达式创建数组。这样的表达式本身可以使用array[]构造函数或数组文本。 

用法：
输入值:       [anyarray | [ anyelement, [anyelement]* ]
返回值:      anyarray

下述函数用以创建一个数组： 

* array_fill()：创建一个指定形状的“空白画布”数组，所有值都设置为所需值。
* array_agg()：从SQL子查询创建一个数组（通常为隐含的“row”类型）。
* text_to_array()：从单个文本值创建一个text[]数组，该数组使用可指定的分隔符将其分隔为各个值。

例如：

```
create type rt as (f1 int, f2 text);
select array[(1, 'a')::rt, (2, 'b')::rt, (3, 'dog \ house')::rt]::rt[] as arr;
```

查询显示如下：

```
                    arr
--------------------------------------------
 {"(1,a)","(2,b)","(3,\"dog \\\\ house\")"}
```

无论何时，显示在bsqlsh中的数组，都会经过隐式的::text类型转换。通过查询该文本值，并将其转换为适当的数组数据类型，可以重新创建起始值。BSQL文档将这种形式的文本称为其规范形式。它的特点是除了文本标量值和日期时间标量值之外，完全没有空白。

### 在PL/pgSQL代码中使用array[]构造函数
下面的示例会在一段代码中提出许多要点。
当array[]构造函数使用的表达式都是文本文字时，实际的语法要比控制如何构造数组文字的语法简单得多。
您可以在PL/pgSQL代码中使用所有BSQL数组功能，就像在SQL语句中一样。代码创建并调用一个表函数，而不仅仅是一个DO块，来强调这一互操作性。
类似数组的功能在任何编程语言中都是必不可少的。
当array[]构造函数使用声明的变量（尤其是用于构建任何预期值的形式参数）组成表达式时，最有价值的。在本例中，值是用户定义的数据类型“rt”。换句话说，当您从运行时首先知道的标量值是以编程方式构建数组时，array[]构造函数特别有价值。
它生动地展示了array[]构造函数的语义效果，如下所示： 

```
declare
  r     rt[];
  two_d rt[];
begin
  ...
  assert (array_dims(r) = '[1:3]'), 'assert failed';
  one_d_1 := array[r[1], r[2], r[3]];
  assert (one_d_1 = r), 'assert failed';
```

运行此操作以创建所需的用户定义的“row”类型和表函数，然后调用它。

```
-- Don't create "type rt" if it's still there following the previous example.
create type rt as (f1 int, f2 text);
 
create function some_arrays()
  returns table(arr text)
  language plpgsql
as $body$
declare
  i1 constant int := 1;
  t1 constant text := 'a';
  r1 constant rt := (i1, t1);
 
  i2 constant int := 2;
  t2 constant text := 'b';
  r2 constant rt := (i2, t2);
 
  i3 constant int := 3;
  t3 constant text := 'dog \ house';
  r3 constant rt := (i3, t3);
 
  a1 constant rt[] := array[r1, r2, r3];
begin
  arr := a1::text;
  return next;
 
  declare
    r rt[];
    one_d_1 rt[];
    one_d_2 rt[];
    one_d_3 rt[];
    two_d   rt[];
    n int not null := 0;
  begin
    ----------------------------------------------
    -- Show how arrays are useful, in the classic
    -- sense, as what EVERY programming language
    -- needs to handle a number of items when the
    -- number isn't known until run time.
    for j in 1..3 loop
      n := j + 100;
      r[j] := (n, chr(n));
    end loop;
 
    -- This further demonstrates the semantics
    -- of the array[] constructor.
    assert (array_dims(r) = '[1:3]'), 'assert failed';
    one_d_1 := array[r[1], r[2], r[3]];
    assert (one_d_1 = r), 'assert failed';
    ----------------------------------------------
 
    one_d_2 := array[(104, chr(104)), (105, chr(105)), (106, chr(106))];
    one_d_3 := array[(107, chr(107)), (108, chr(108)), (109, chr(109))];
 
    -- Show how the expressions that define the outcome
    -- of the array[] constructor can themselves be arrays.
    two_d := array[one_d_1, one_d_2, one_d_3];
    arr := two_d::text;
    return next;
  end;
 
end;
$body$;
 
select arr from some_arrays();
```

产生两行，下面是第一行：

```
                    arr
--------------------------------------------
 {"(1,a)","(2,b)","(3,\"dog \\\\ house\")"}
```

这是第二行。通过手动添加一些空白，提高了可读性： 

```
{
  {"(101,e)","(102,f)","(103,g)"},
  {"(104,h)","(105,i)","(106,j)"},
  {"(107,k)","(108,l)","(109,m)"}
}
```

### 在准备好的语句中使用array[]构造函数
这个示例强调了使用array[]构造函数，而不是使用数组文本文字的价值，因为它允许您在其中使用类似chr() 的表达式。

```
-- Don't create "type rt" if it's still there followng the previous examples.
create type rt as (f1 int, f2 text);
create table t(k serial primary key, arr rt[]);
 
prepare stmt(rt[]) as insert into t(arr) values($1);
 
-- It's essential to typecast the individual "rt" values.
execute stmt(array[(104, chr(104))::rt, (105, chr(105))::rt, (106, chr(106))::rt]);
```

使用数组文本文字作为实际参数来执行准备好的语句，在语义上是等效的：

```
execute stmt('{"(104,h)","(105,i)","(106,j)"}');
```

但在这里，当然，你只需要事先知道chr(104)是h，依此类推。因此，证明准备语句的两次执行的结果是相同的：

```
select
  (
    (select arr from t where k = 1)
    =
    (select arr from t where k = 2)
  )::text as result;
```

显示如下：

```
 result
--------
 true
```

## **常量**

本节通过几个示例非正式地介绍数组文字。下面列出的小节正式解释了如何构造语法正确的数组文字，以确定创建想要的值。
数组文本文字以左大括号开头，接下来是数组值的一些逗号分隔的文本文字表示。有时，值的表示不需要双引号，但也可以使用双引号，但有时值的表示必须使用双引号，然后数组文本文字以右大括号结束。
根据数组的数据类型，其值可能是标量，也可能是复合值。
例如，它们可能是“row”类型的值；或者它们可以是数组。多维数组的文本文字被写成数组的数组，等等。它们甚至可能是基于数组数据类型的用户定义DOMAIN的值。这个强大的概念将在专门的使用DOMAIN值数组一节中讨论。
要在SQL或PL/pgSQL中使用这样的文本文字，必须以与普通文本文本相同的方式对其进行查询。如果这符合您的目标，您可以使用美元引号查询数组文字，就像您可以查询文本文字一样。有时，您需要在右引号后面为所需的数组数据类型添加合适的类型转换运算符。有时，使用上下文唯一地决定了文本文字的数据类型。推荐使用显式地类型转换。 
在这里，SQL SELECT语句中使用的，是基于int值的一维数组的文本文字：

```
\t on
select '{1, 2, 3}'::int[];
```

\t on 元命令禁止列标题，并在这些标题下取消规则。除非标题很重要，否则bsqlsh的查询输出将在当前的“数组”主要部分中显示，而不显示这些。

这是第一个示例产生的输出： 

```
{1,2,3}
```

第二个示例，是使用双引号，来引起数组文本文字定义的值：

```
select '{"1", "2", "3"}'::int[];
```

它产生的输出与第一个示例相同，其中没有使用双引号。

第三个示例定义了int值的二维数组： 

```
select '
   {
      {11, 12, 13},
      {21, 22, 23}
    }
  '::int[];
```

输出返回如下信息：

```
 {{11,12,13},{21,22,23}}
```

第四个示例定义了一个数组，其值是“row”类型的实例： 

```
create type rt as (f1 int, f2 text);
 
select '
  {
    "(1,a1 a2)",
    "(2,b1 b2)",
    "(3,c1 v2)"
  }
'::rt[];
```

输出返回如下信息：

```
{"(1,\"a1 a2\")","(2,\"b1 b2\")","(3,\"c1 v2\")"}
```

所有空白（除了文本值中的空白之外）都已删除。每个“row”类型值的表示形式周围的双引号将被保留（删除会导致“22P02:格式错误的行文字”错误）。最值得注意的是，在每个“row”类型值的表示中，有明显的规则与每个文本的值有关。 

以下各节仔细介绍了规则，并在规则允许情况下，提出一定的建议。

### 值文本类型转换、该值的文本文字，以及它们之间的关系
本节建立了一些基本概念，这些概念的适用范围远不止数组。但是，因为使用数组文本文字是基于这些概念，所以在这里对它们进行了总结。
#### *值到文本的类型转换和返回值*
考虑以下模式：

```
do $body$
declare
  original   constant <some data type>  not null := <some value>;
  text_cast  constant text              not null := original::text;
  recreated  constant <some data type>  not null := text_cast::<some data type>;
begin
  assert
    (recreated = original),
  'assert failed';
end;
$body$;
```

它展示了BSQL从PostgreSQL继承的一个通用规则： 

* 任意数据类型的任意值都可以使用::text转换。类似地，总是存在一个文本值，当拼写正确时，可以将其类型转换为任何所需数据类型的值，无论是基本还是复合数据类型。
* 如果使用::text对任何数据类型的值进行类型转换，然后将该文本值类型转换为原始值的数据类型，则获得的值与原始值相同。 

如下的DO块使用基本和复合数据类型的代表性范围应用模式（不包括退化大小写的数据类型text）。它还显示每个数据类型的::text转换值。

```
-- Needed by the '1-d array of "row" type values' test.
create type rt as (n numeric, s text, t timestamp, b boolean);
 
-- Needed by the 'Ragged array' test.
create domain int_arr_t as int[];
 
do $body$
begin
  -- numeric
  declare
    original   constant numeric  not null := 42.1763;
    text_cast  constant text     not null := original::text;
    recreated  constant numeric  not null := text_cast::numeric;
  begin
    assert
      (recreated = original),
    'assert failed';
    raise info 'numeric:              %', text_cast;
  end;
 
  -- timestamp
  declare
    original   constant timestamp  not null := now()::timestamp;
    text_cast  constant text       not null := original::text;
    recreated  constant timestamp  not null := text_cast::timestamp;
  begin
    assert
      (recreated = original),
    'assert failed';
    raise info 'timestamp:            %', text_cast;
  end;
 
  -- timestamp with timezone
  declare
    original   constant timestamptz  not null := now()::timestamptz;
    text_cast  constant text         not null := original::text;
    recreated  constant timestamptz  not null := text_cast::timestamp;
  begin
    assert
      (recreated = original),
    'assert failed';
    raise info 'timestamptz:          %', text_cast;
  end;
 
  -- boolean
  declare
    original   constant boolean  not null := true;
    text_cast  constant text     not null := original::text;
    recreated  constant boolean  not null := text_cast::boolean;
  begin
    assert
      (recreated = original),
    'assert failed';
    raise info 'boolean:              %', text_cast;
  end;
 
  -- "row" type
  declare
    original   constant rt    not null := row(42.1763, 'dog house', now(), true);
    text_cast  constant text  not null := original::text;
    recreated  constant rt    not null := text_cast::rt;
  begin
    assert
      (recreated = original),
    'assert failed';
    raise info '"row" type:           %', text_cast;
  end;
 
  -- 2-d array
  declare
    original   constant int[]  not null := array[array[1, 2], array[3, 4]];
    text_cast  constant text   not null := original::text;
    recreated  constant int[]  not null := text_cast::int[];
  begin
    assert
      (recreated = original),
    'assert failed';
    raise info '2-d array             %', text_cast;
  end;
 
  -- 1-d array of "row" type values
  declare
    original   constant rt[]  not null :=
      array[
        row(42.1763, 'dog house', now(),                    true),
        row(19.8651, 'cat flap',  now() + interval '1' day, false)
      ];
    text_cast  constant text  not null := original::text;
    recreated  constant rt[]  not null := text_cast::rt[];
  begin
    assert
      (recreated = original),
    'assert failed';
    raise info 'array of "row" type:  %', text_cast;
  end;
 
  -- Ragged array: 1-d array of 1-da arrays of different lengths.
  declare
    arr_1      constant int_arr_t    not null := array[1, 2];
    arr_2      constant int_arr_t    not null := array[3, 4, 5];
    original   constant int_arr_t[]  not null := array[arr_1, arr_2];
    text_cast  constant text         not null := original::text;
    recreated  constant int_arr_t[]  not null := text_cast::int_arr_t[];
  begin
    assert
      (recreated = original),
    'assert failed';
    raise info 'array of arrays:      %', text_cast;
  end;
end;
$body$;
```

输出如下类似结果（在手动删除每个输出行上的“INFO:”提示）

```
numeric:              42.1763
timestamp:            2020-05-03 22:25:42.932771
timestamptz:          2020-05-03 22:25:42.932771-07
boolean:              true
"row" type:           (42.1763,"dog house","2020-05-03 22:25:42.932771",t)
2-d array             {{1,2},{3,4}}
array of "row" type:  {"(42.1763,\"dog house\",\"2020-05-03 22:25:42.932771\",t)","(19.8651,\"cat flap\",\"2020-05-04 22:25:42.932771\",f)"}
array of arrays:      {"{1,2}","{3,4,5}"}
```

请注意数组的数组的text值语法与二维数组text值的语法的比较。因为数组的数组是不规则的，所以两个内部{}对分别包含两个和三个值。为了区分这种情况和普通的直线情况，内{}对被双引号包围。

#### *布尔值显示在bsqlsh中的特殊文本形式*
尝试执行如下脚本：

```
select true as "bare true", true::text as "true::text";
```

返回如下：

```
 bare true | true::text
-----------+------------
 t         | true
```

对于除布尔值以外的所有值，bsqlsh用于显示任何值的字符串都是该值的::text 类型转换。毕竟，唯一可行的显示方式是字符串。但对于关键字TRUE和FALSE表示的两个布尔值，它唯一使用的是单个字符t和f，而不是它们的::text 类型转换，除非显式类型转换。 
此行为是从psql继承来的。
从上面可以看到，即使显式地::text 类型转换为复合值，TRUE和FALSE也表示为t和f。您不能影响此结果，因为它与派生类型转换文本的规则有关，而与bsqlsh使用的约定无关。这种不对称性是多年前建立的，无法改变。

#### *值的text类型转换与创建该值的文字之间的关系*
尝试执行如下脚本：

```
select
  42.932771::numeric          as n,
  'cat'::text                 as t1,
  $$dog's breakfast$$::text   as t2,
  array[1, 2, 3]::int[]       as "int array";
```

输出如下类似结果

```
  n     | t1  |       t2      | int array
-----------+-----+---------------------+-----------
42.932771 | cat | dog's breakfast  | {1,2,3}}
```

首先考虑这一点：

```
42.932771::numeric
```

这是SQL语言（至少在BSQL和PostgreSQL中）用来建立相应的强类型数值的文字。PL/pgSQL使用相同的形式用于相同的目的。但是，显而易见的是，SQL语句和PL/pgSQL源只不过是字符串。这意味着，在目前的情况下，这个： 

```
42.932771
```

是文本文字

接下来，考虑如下：

```
'cat'::text          $$dog's breakfast$$::text
```

SQL和PL/pgSQL的解析规则（或者更恰当地说，这两种语言的语法定义）都要求对文本文本进行查询。此外，有两种句法机制可以做到这一点：普通的单引号；以及所谓的美元符号，其中$$是更一般的$anything_you_want$的特例。您可能会认为::text类型转换在这里是多余的。但不要忘记，这些文字的文本可能用于建立varchar或char值。 
可以看到，组成数字文字和文本文字的规则是不同的：

* 您可以使用纯文本编写指定带有::numeric转换运算符的预期值的数字文本。
* 您可以使用纯文本编写指定带有::text 转换运算符的预期值的文本文字。
  （如果你确实在数字文本中查询了纯文本，那么你不会看到错误。相反，你会得到隐含但不期望的行为：首先，会在内部生成一个真正的文本值，然后，它会被转换为数字值。）
  您已经看到了一些数组文字的示例。规则如下：
* 通过用专用语法编写一个以左大括号开始、以右大括号结束，可以编写指定预期值的纯文本，此语法是使用文本文字创建数组值的剩余部分的重点。然后查询这个纯文本（无论您选择如何引用），然后将其类型转换为所需的目标数组数据类型。

这些是一个更一般规则的三种特殊情况。在某些情况下（例如，在“row”类型值的文字中），查询机制可能是可选的（取决于预期值），并且在编写时使用双引号作为查询字符。但在这里，一般规则也是一样的。指定预期值的纯文本始终可以正确地写成该值的::text类型转换。

一般规则
如下是一般规则：

* 任何数据类型的值的文本都可能是指定预期值的查询纯文本，后面是所需目标数据类型的转换运算符。
* 这个规则被递归应用于复合值的文字，但在不同的嵌套级别上有不同的实际规则。例如，数组值的文字作为一个整体必须是类型转换的。但是，因为数组中每个值的数据类型都已经确定，所以指定这些值的纯文本不是类型转换的。
* 任何值的::text类型转换都可以用作将重新创建该值的文字的纯文本。 

您可以看到创建数组值的文字的文本示例，方法是使用构造函数创建值，然后检查其::text类型转换。但是，为预期值创建文本的安全方法是理解支配其组成的语法和语义。
#### *定义“文字的规范形式”* 
术语“规范形式”专门适用于文字的文本，而不是整个文字。但是，当文字的文本是规范形式时，文字作为一个整体也是规范形式的。 
产生任何数据类型的特定值的文本的规范形式是该值的::text 类型转换。 
“数组数据类型和功能”主要部分中的许多示例表明，除了规范形式外，数组文本的许多拼写还会产生特定的目标值。不同之处在于空格、标点符号和转义符的使用方式。

## **基础值数字文字文本**

本节介绍了足够多的规则子集，这些规则允许您编写语法正确的数组文字，该文字表示您可能想要创建的任何标量数据类型的数组。全套规则比这里所说的规则更具灵活性。但因为这些是足够的，所以这里没有记录完整的、相当复杂的集合。本节中的解释肯定允许您解释您可能看到的任何数组值的 ::text类型转换，例如在bsqlsh中，阐述了AiSQL在这一领域的建议，然后举例说明这些规则。
### 规则声明
这些规则的声明取决于对文字规范形式概念的理解。定义“文本的规范形式”解释说，任何类型的数组的::text 类型转换都会向您表明，这种形式的文本（更仔细地说，是这个文本的文字）可以用于重新创建该值。
事实上，这个定义，以及文字的规范形式足以重新创建值的属性，适用于所有数据类型的值。
数组中的每个值都必须具有相同的数据类型。如果遵循规则，那么将始终生成一个语法有效的文本。事实证明，许多其他变体，尤其是text[]数组，都是合法的，可以产生您想要的值。然而，外来用途的规则将不会被记录下来，因为以规范的形式创建文本文字已经足够了。
这是一套足够充分的规则：

* 分隔连续值的逗号、包含整个文字的大括号，以及多维数组的文字中使用的内部大括号，可以被任意数量的空格包围。如果想严格遵守规范的形式，那么不应该这样做。但是这样做可以提高临时手动键入文字的可读性，它还可以使在以编程方式构造数组文字的程序中读取跟踪输出变得更加容易。
* 在numeric 和boolean 数组文字中，不要用双引号将各个值括起来。 
* 在timestamp[]数组的文本中，请使用双引号将各个值括起来，尽管这不是绝对必要的。
* 在text[]数组的文本中，用双引号将每个单独的值括起来，尽管这并不总是必要的。但是对于本身包含最外层大括号对，其中具有语法意义的任何空白或任何字符，却是必要的。以下是列表：
  <space>   {   }   ,   "   \
* 通常在括起来的双引号内写大括号和逗号就足够了。但是，每个双引号字符和反斜杠字符，都必须使用紧挨在前的单个反斜杠进行转义。

### 以规范形式写入数组文本文字
一般来讲，很少会像本节演示规则那样手动键入文本，可能只有在自学、构建新代码原型或调试时，才会这样做。通常，会在客户端程序中以编程方式创建文本，该程序解析数据值，例如，XML文本文件，或者，可能是JSON文本文件。在这些场景中，目标数组的数据类型可能为“some_user_defined_row_type[]”。当以编程方式创建时，希望使用最简单的规则工作，并且无需省略不必要的双引号字符。

注：AiSQL建议，通过编程生成的数组文本文字始终使用规范表示进行拼写

您可以放宽这一建议，以便更容易地跟踪或调试代码，方法是在数组中的每个连续编码值之间使用一换行符，至少当值本身使用大量字符时是这样，因为它们可能用于“row”类型的值。
注意：您希望您使用的客户端编程语言，以及用于向AiSQL发布SQL和检索结果的驱动程序，允许直接使用映射到BSQL数组和“row”类型的数据类型，就像它们具有映射到int、text、timestamp和boolean的标量数据类型一样。例如，Python有映射到数组的“list”，映射到“row”类型的“tuple”。用于AiSQL的“psycopg2”驱动程序可以将这些数据类型的值映射到，如下所示的PREPARE语句。
注意：BSQL支持将JSON数组（其中包括JSON对象的JSON数组）直接转换为相应的BSQL数组值。
在“row”类型值数组的文本部分中，描述了为“row”型值数组构造文本的规则。
您的程序将解析输入，并创建所需的文字作为普通文本字符串，然后将其作为PREPARE语句执行的实际参数提供，将文本实际参数的类型转换为适当的数组数据类型，提供给准备好的INSERT或UPDATE语句，如下所示： 

```
prepare stmt(text) as insert into t(rs) values($1::rt[]);
```

假设在本例中，“rt”是某个特定的用户定义的“row”类型。

### 举例说明规则
以下是基本数据类型值的数组的一些示例：

* 数值数组（如int和numeric）
* 字符串值数组（如text、varchar和char）
* 日期-时间值数组（如时间戳）
* 布尔值数组。

为了解释说明数组文本文字构造的规则，只考虑这些规则就已经足够了。
使用array[]构造函数来创建每种类型，并检查其::text类型转换 

#### *int值的一维数组*
看一下如下示例： 

```
create table t(k serial primary key, v1 int[], v2 int[]);
insert into t(v1) values (array[1, 2, 3]);
select v1::text as text_typecast from t where k = 1
\gset result_
\echo :result_text_typecast
```

此示例演示了以下原则：
“数组数据类型和功能”章节部分中的array_agg（）和unnest（），使用了\gset meta命令。
请注意，在本例中，SELECT语句由下一行的\gset 元命令终止，而不是由通常的分号终止。\echo 元命令显示以下内容：

```
{1,2,3}
```

您已经可以看到一般形式如：

* 数组文本文字的以左大括号开始，以右大括号结束。
* 大括号内的项由逗号分隔，项、逗号，于下一项之间没有空格。左大括号和第一个项之间，或者最后一项和右大括号之间，均没有任何空格。 

文本值的一维数组表明，还需要说明更多内容。但你已经注意到的两条规则始终适用。
若要使用生成的文本文字来创建值，必须对其进行查询，并进行类型转换。请使用\set 元命令执行以下操作：

```
\set canonical_literal '\'':result_text_typecast'\'::int[]'
\echo :canonical_literal
```

\echo 元命令显示以下内容： 

```
'{1,2,3}'::int[]
```

接下来，使用生成的规范文本来更新“t.v2”，以确认行构造函数创建的值已重新创建：

```
update t set v2 = :canonical_literal where k = 1;
select (v1 = v2)::text as "v1 = v2" from t where k = 1;
```

查询返回如下：

```
 v1 = v2
---------
 true
```

可以看到，数组文字的规范形式确实重新创建了array[]构造函数创建的相同值。

注意：
尝试执行如下：

```
select 12512454.872::text;
```

结果是规范形式，12512454.872

```
select 12512454.872::numeric;
```

运行时也没有出现错误。现在试试这个

```
select to_number('12,512,454.872', '999G999G999D999999')::text;
 
This, too, runs without error because it uses the to_number() built-in function. The result here, too, is the canonical form, 12512454.872—with no commas. Now try this:
```

由于它使用了to_number（）内置函数，因此运行时也不会出错。这里的结果也是规范形式，12512454.872，没有逗号。现在试试这个：

```
select '12,512,454.872'::numeric;
```

这个会引发“22P02:类型数字的无效输入语法”错误。换句话说，只有规范形式的数值才能使用::numeric直接进行类型转换。

这里，使用数组文字，是对以下内容第一次了解。现在，把它的语法理解为你直觉上所期望的意思。必须以规范形式拼写numeric[] 数组中值的表示形式。请尝试以下操作：

```
select ('{123.456, -456.789}'::numeric[])::text;
```

返回如下信息：

```
 {123.456,-456.789}
```

继续尝试如下操作：

```
select ('{9,123.456, -8,456.789}'::numeric[])::text;
```

它会无声地产生这种可能是意外的结果（四个数值的数组），因为逗号被用作分隔符，而不是单个数值表示的一部分：

```
 {9,123.456,-8,456.789}
```

在数组文字（或“row”类型值文字）中，无法容纳不能直接进行类型转换的表单。（时间戳值和数值也是如此。）BSQL从PostgreSQL继承了这一限制。在准备文本文字时，用户有责任解决这个问题，因为，像“to_number()”这样的函数不能在文字中使用。然而，函数可以在值构造函数中使用，如array[]值构造函数所示 ：

#### *一维text值数组* 
看一下如下示例：

```
create table t(k serial primary key, v1 text[], v2 text[]);
insert into t(v1) values (array['a', 'a b', '()', ',', '{}', $$'$$, '"', '\']);
select v1::text as text_typecast from t where k = 1
\gset result_
\echo :result_text_typecast
```

出于特殊原因，数组值本身必须被引起来，需要一些特殊的东西构成单引号，才能在SQL中使用，此时，美元符号就是一个方便的选择。\echo 元命令显示以下内容：

```
{a,"a b",(),",","{}",',"\"","\\"}
```

这或许很难解析。为了使规则更易于查看，此列表不会显示左和右大括号。语法上有意义的逗号两边各有四个空格：

​    a    ,    "a b"    ,    ()    ,    ","    ,    "{}"    '    ,    "\\""    ,    "\\\\"

除了前两条规则外，还应注意以下： 

* 双引号用于将包含任何空格的值括起来。（虽然示例中没有显示，但这也适用于前导空格和尾随空格。）
* 左右括号没有用双引号括起来。尽管这些在其他解析上下文中具有语法意义，但在数组文字的大括号中是无关紧要的。
* 逗号被双引号括起来。这是因为，它在数组文字的大括号中，作为值分隔符，确实具有语法意义。
* 大括号被双引号括起来。这是因为，内部大括号在多维数组的数组文字中确实具有语法意义，如下所示。
* 单引号不会被双引号括起来。尽管它在其他解析上下文中具有语法意义，但在数组文字的大括号中是无关紧要的。这也适用于其他各种标点符号，比如 ; 和 : 和 [ 和 ] 等等。
* 双引号用一个反斜杠转义，然后用双引号括起来。这是因为它作为（唯一的）引用机制，在数组文字的大括号中确实具有语法意义。 
* 反斜杠也用另一个单反斜杠转义，然后用双引号将其括起来。这是因为它作为转义符在数组文字的大括号中确实具有语法意义。
  还有另一条规则，这个示例没有显示出来。虽然不是每个逗号分隔的值都被双引号括起来，但这样做没有坏处。你可以通过自己的测试来证实这一点，AiSQL建议，为了保持一致性，你总是用双引号将text[]数组文字的每个文本值都括在大括号内。
  若要使用上面生成的文本来重新创建值，必须对其进行查询，并进行类型转换。请使用\set 元命令执行此操作，就像对上面的int[] 示例所做的那样。但您必须使用美元符号，因为文字本身有一个内部单引号。

```
\set canonical_literal '$$':result_text_typecast'$$'::text[]
\echo :canonical_literal
```

\echo 元命令现在显示以下内容：

```
$${a,"a b",(),",",',"\"","\\"}$$::text[]
```

接下来，使用规范文本更新“t.v2”，来确认行构造函数创建的值已重新创建：

```
update t set v2 = :canonical_literal where k = 1;
select (v1 = v2)::text as "v1 = v2" from t where k = 1;
```

应该返回如下信息：

```
 v1 = v2
---------
 true
```

#### *一维timestamp值数组* 
看一下如下示例：

```
create table t(k serial primary key, v1 timestamp[], v2 timestamp[]);
insert into t(v1) values (array[
    '2019-01-27 11:48:33'::timestamp,
    '2020-03-30 14:19:21'::timestamp
  ]);
select v1::text as text_typecast from t where k = 1
\gset result_
\echo :result_text_typecast
```

\echo 元命令现在显示以下内容：

```
{"2019-01-27 11:48:33","2020-03-30 14:19:21"}
```

您可以从中进一步了解一条规则：

* 大括号中的::timestamp类型转换字符串用双引号括起来。

若要使用生成的文本来创建值，必须对其进行查询，并进行类型转换。请使用\set 元命令执行此操作：

```
\set canonical_literal '\'':result_text_typecast'\'::timestamp[]'
\echo :canonical_literal
```

\echo 元命令现在显示以下内容：

```
'{"2019-01-27 11:48:33","2020-03-30 14:19:21"}'::timestamp[]
```

接下来，使用规范文本更新“t.v2”，来确认行构造函数创建的值已重新创建：

```
update t set v2 = :canonical_literal where k = 1;
select (v1 = v2)::text as "v1 = v2" from t where k = 1;
```

返回信息如下：

```
 v1 = v2
---------
 true
```

#### *一维Boolean值数组（通常为NULL）* 
看一下如下示例：

```
create table t(k serial primary key, v1 boolean[], v2 boolean[]);
insert into t(v1) values (array[
    true,
    false,
    null
  ]);
select v1::text as text_typecast from t where k = 1
\gset result_
\echo :result_text_typecast
```

\echo 元命令现在显示以下内容：

```
{t,f,NULL}
```

可从中了解两条规则:

* boolean[]数组的花括号中，TRUE和FALSE的规范表示为t和f。它们不被双引号括起来。
* 指定NULL，规范形式使用大写NULL，并且不使用双引号将其括起来。

尽管示例中没有显示这一点，但NULL不区分大小写。但要编写一个符合规范形式的文字，您应该使用大写字母拼写。这就是在任何数据类型的数组文字中指定NULL的方法。（不同的规则适用于“row”类型值的文字中的字段）。 

注意：如果您在text[]数组的文本中括起来NULL，那么它将被无声地解释为一个普通的文本值。
若要使用生成的文字来创建值，必须对其进行查询，并进行类型转换。请使用\set 元命令执行以下操作：

```
\set canonical_literal '\'':result_text_typecast'\'::boolean[]'
\echo :canonical_literal
```

\echo 元命令现在显示以下内容：

```
'{t,f,NULL}'::boolean[]
```

接下来，使用规范文本更新“t.v2”，来确认行构造函数创建的值已被重新创建：

```
update t set v2 = :canonical_literal where k = 1;
select (v1 = v2)::text as "v1 = v2" from t where k = 1;
```

返回信息如下：

```
 v1 = v2
---------
 true
```

#### *int值的多维数组* 
看一下如下示例：

```
create table t(k serial primary key, v int[]);
 
-- Insert a 1-dimensional int[] value.
insert into t(v) values('
    {1,  2}
  '::int[]);
 
-- Insert a 2-dimensional int[] value.
insert into t(v) values('
    {
      {1,  2},
      {3,  4}
    }
  '::int[]);
 
-- Insert a 3-dimensional int[] value.
insert into t(v) values('
    {
      {
        {1,  2}, {3,  4}
      },
      {
        {5,  6}, {7,  8}
      }
    }
  '::int[]);
 
-- Insert a 3-dimensional int[] value, specifying
-- the lower and upper bounds along each dimension.
insert into t(v) values('
    [3:4][5:6][7:8]=
    {
      {
        {1,  2}, {3,  4}
      },
      {
        {5,  6}, {7,  8}
      }
    }
  '::int[]);
 
select k, array_ndims(v) as "ndims", v::text as "v::text" from t order by k;
```

请注意，三个不同的INSERT语句定义了具有不同维度的数组。这说明了大纲中所解释的内容：列“t.v”可以包含任何维度的数组值。

返回信息如下：

```
 k | ndims |                    v::text
---+-------+-----------------------------------------------
 1 |     1 | {1,2}
 2 |     2 | {{1,2},{3,4}}
 3 |     3 | {{{1,2},{3,4}},{{5,6},{7,8}}}
 4 |     3 | [3:4][5:6][7:8]={{{1,2},{3,4}},{{5,6},{7,8}}}
```


同样，为数值插入的文字中的空白是无关紧要的，而文本类型转换通常使用空白（实际上，缺少空白）。 

多维数组的文字根据维度有嵌套的｛｝对，最里面的一对包含基本数据类型值的文本文字。

请注意带有“k = 4”的行的数组文本文字的拼写。可选语法[3:4][5:6][7:8]分别指定第一维度、第二维度和第三维度的下界和上界。这与用于指定数组切片的语法相同。当没有指定边界时，它们都是从1开始，然后文本文字的规范形式不显示边界。

在指定边界时，可能会引发出错。如果您（隐含地）指定的沿每个轴的长度，与｛｝对之间列出的实际值中出现的长度不一致，则您会得到“22P02 invalid_text_representation”的错误： 

```
malformed array literal...
Specified array dimensions do not match array contents.
```

## **“row”类型值的文本文字**

“row”一词有两种不同的用法。模式级表中的行实际上是“row”类型的一个实例，换句话说，是一个“row”型值。在这种情况下，模式级别的“row”类型是作为执行CREATE TABLE语句的副作用而自动创建的。它与表同名。这是允许的，因为表和类型位于不同的命名空间中。此外，模式级表中的列可以具有用户定义的“row”类型作为其数据类型，在这种情况下，“row”类型不需要与表合作。

当您使用\df 元命令来显示函数时，您可能会看到术语“record”。简单地说，它是一种匿名的“row”类型。当您使用具有正确形式的“row”类型的文本文字，但省略了类型转换运算符时，将生成记录实例。如果你坚持推荐的做法，并且总是明确地键入这样的文字，那么你就不必试图理解什么是记录。您可以在PostgreSQL文档中阅读更多关于这些概念的相关信息。

### 规则声明
如果您遵循这里所述的规则，并进行说明，那么您将始终生成一个语法有效的文本。事实证明，许多其他变体，尤其是text[]值，是合法的，可以产生您想要的结果。然而，管理这些外来用途的规则不会被记录下来，因为以规范的形式创建文本文字已经足够了。
规则如下：

* 分隔连续值的逗号，以及左括号和右括号，不能被空格包围。
* 不要用双引号将数字和布尔基本数据类型的值括起来。
* 请用双引号将时间戳值的各个表示形式括起来，即使这不是绝对必要的。
* 请用双引号将文本值的每个单独表示形式括起来，即使这并不总是必要的。对于任何值，如普通文本，其本身包含最外层大括号对，其中具有语法意义的任何空白或任何字符，则都是必要的。以下是列表：
  \<space>   (   )   ,   "   \\
* 那么，除了双引号字符本身和反斜杠字符之外，通常在括起来的双引号中写入所有特殊字符就足够了。双引号字符是通过将其加倍来转义的。并且反斜杠字符使用紧挨在前的单个反斜杠进行转义。 
* 要指定字段的值为NULL，必须在其位置周围的一对分隔符（左括号、逗号或右括号）之间不留空白。

### 示例
只考虑具有以下数据类型的字段的“row”类型就足够了解规则了： 

* 数字数据类型（如int和numeric）
* 字符串数据类型（如text、varchar和char）
* 日期-时间数据类型（如时间戳）
* 布尔数据类型。
  使用“row”类型构造函数创建每种类型，并检查其::text 类型转换。

#### *int字段的“row”类型*
看一下如下示例：

```
create type row_t as (f1 int, f2 int, f3 int);
create table t(k serial primary key, v1 row_t, v2 row_t);
insert into t(v1) values (row(1, 2, 3)::row_t);
select v1::text as text_typecast from t where k = 1
\gset result_
\echo :result_text_typecast
```

关键字ROW命名“row”类型的构造函数函数，是可选的。 
“数组数据类型和功能”章节部分中的array_agg（）和unnest（），使用了\gset meta命令。
请注意，在本例中，SELECT语句由下一行的\gset 元命令终止，而不是由通常的分号终止。\echo 元命令显示以下内容：

```
(1,2,3)
```

在这种情况下，::text类型转换的值与“row”类型构造函数的值具有相同的形式。但是，正如下文所示，情况并非如此。 
一般来说：

* “row”类型文字的（文本）以左括号开始，以右括号结束。
  括号内的项由逗号分隔，项、逗号和下一个项之间没有空格。左括号和第一项之间，或最后一项和右括号之间也没有空格。

若要使用生成的文本文字来创建值，必须对其进行查询，并进行类型转换。请使用\set 元命令执行此操作：

```
\set canonical_literal '\'':result_text_typecast'\''::row_t
\echo :canonical_literal
```

\echo 元命令显示以下内容：

```
'(1,2,3)'::row_t
```

接下来，使用规范文本更新“t.v2”，来确认行构造函数创建的值已被重新创建：

```
update t set v2 = :canonical_literal where k = 1;
select (v1 = v2)::text as "v1 = v2" from t where k = 1;
```

输出信息如下：

```
 v1 = v2
---------
 true
```

#### *text字段的“row”类型*
看一下如下示例：

```
create type row_t as (f1 text, f2 text, f3 text, f4 text, f5 text, f6 text, f7 text, f8 text);
create table t(k serial primary key, v1 row_t, v2 row_t);
insert into t(v1) values (  ('a', $$'$$, 'a b', '()', ',', '"', '\', null)::row_t);
 
select v1::text as text_typecast from t where k = 1
\gset result_
\echo :result_text_typecast
```

这里，省略了“row”类型构造函数函数中的ROW关键字，以强调其可选状态。
\echo 元命令显示以下内容：

```
(a,',"a b","()",",","""","\\",)
```

这或许很难解析。为了使规则更易于查看，语法上有意义的逗号两边各用三个空格括起来：

(   a   ,   '   ,   "a b"   ,   "()"   ,   ","   ,   """"   ,   "\\\\"   ,   )

注意：为了便于阅读，此处引入空格仅用于此目的。与数组文字的情况不同，这样做实际上会影响文字产生的值。您将在本节末尾演示这一点。  

除了前两条规则外，还应注意以下：

* 双引号用于将包含任何空格的值括起来。（虽然示例中没有显示，但这也适用于前导空格和尾随空格。）
* 逗号被双引号括起来。这是因为它作为值分隔符，在“row”类型文字的括号内确实具有语法意义。
* 括号被双引号括起来。这是因为这些确实具有句法意义。
* 单引号不会被双引号括起来。尽管它在其他解析上下文中具有语法意义，但在“row”类型文字的括号中是无关紧要的。这也适用于其他各种标点符号，比如 ; 和 : 和 [ 和 ] 等等。
* 双引号是通过将其加倍来转义的，然后用双引号将其括起来。这是因为它确实具有句法意义，作为（唯一的）引用机制，位于“row”类型文字的括号内。
* 反斜杠也用另一个单反斜杠转义，然后用双引号将其括起来。这是因为它确实具有语法意义，作为转义符，位于“row”类型文字的括号内。 
* NULL在“row”类型的文字中表示为两个连续分隔符之间没有任何字符：左括号和第一个逗号之间，两个连续逗号之间，或最后一个逗号和右括号之间。
  还有另一条规则，这个示例没有显示出来。虽然不是每个逗号分隔的值都被双引号括起来，但这样做从来没有坏处。你可以通过自己的测试来证实这一点，AiSQL建议，为了保持一致性，你应该总是用双引号将“row”类型的括号内的每个文本值括起来。
  要使用生成的文本来创建值，必须对其进行查询，并进行类型转换。请使用\set 元命令执行此操作，就像上面的int示例一样。但您必须使用美元符号，因为文字本身有一个内部单引号。

```
\set canonical_literal '$$':result_text_typecast'$$'::row_t
\echo :canonical_literal
```

\echo 元命令显示以下内容：

```
$$(a,',"a b","()",",","""","\\",)$$::row_t
```

接下来，使用规范文本更新“t.v2”，来确认行构造函数创建的值已被重新创建：

```
update t set v2 = :canonical_literal where k = 1;
select (v1 = v2)::text as "v1 = v2" from t where k = 1;
```

输出信息如下：

```
 v1 = v2
---------
 true
```

在本节的最后，考虑用空格括起来逗号分隔符的意义。如下示例：

```
create type row_t as (f1 text, f2 text, f3 text);
select '(   a   ,   "(a b)"   ,   c   )'::row_t;;
```

输出信息如下：

```
 ("   a   ","   (a b)   ","   c   ")
```

可以将一对分隔符之间的整个字符序列都理解为值来理解这一点。双引号起到了内部逃逸机制的作用。仅当一对分隔符之间的值被解释为文本值时，该模型才成立（因为在此位置，这是被声明的“row”类型字段的数据类型）。 

这个规则与数组文字的规则不同，而且，也不同于JSON文档的规则。在这些情况下，值完全在双引号内，双引号外，标点符号周围的空格是无关紧要的。

注：AiSQL建议您始终使用“几乎规范”的文本形式。换句话说，即使不需要双引号，也要用双引号将每个文本值括起来，并且在这些双引号值，和每个此类值开头和结尾的分隔符之间不允许有空格。

#### *timestamp字段的“row”类型*
看一下如下示例：

```
create type row_t as (f1 timestamp, f2 timestamp);
create table t(k serial primary key, v1 row_t, v2 row_t);
insert into t(v1) values (('2019-01-27 11:48:33', '2020-03-30 14:19:21')::row_t);
select v1::text as text_typecast from t where k = 1
\gset result_
\echo :result_text_typecast 
```

\echo 元命令显示以下内容：

```
("2019-01-27 11:48:33","2020-03-30 14:19:21")
```

若要使用生成的文本来创建值，必须对其进行查询，并进行类型转换。请使用\set 元命令执行此操作：

```
\set canonical_literal '\'':result_text_typecast'\''::row_t
\echo :canonical_literal
```

\echo 元命令显示以下内容：

```
'("2019-01-27 11:48:33","2020-03-30 14:19:21")'::row_t
```

接下来，使用规范文本更新“t.v2”，来确认行构造函数创建的值已被重新创建：

```
update t set v2 = :canonical_literal where k = 1;
select (v1 = v2)::text as "v1 = v2" from t where k = 1;
```

输出信息如下：

```
 v1 = v2
---------
 true
```

#### *boolean字段的“row”类型*
看一下如下示例：

```
create type row_t as (f1 boolean, f2 boolean, f3 boolean);
create table t(k serial primary key, v1 row_t, v2 row_t);
insert into t(v1) values ((true, false, null)::row_t);
select v1::text as text_typecast from t where k = 1
\gset result_
\echo :result_text_typecast 
```

\echo 元命令显示以下内容：

```
 (t,f,)
```

若要使用生成的文本来创建值，必须对其进行查询，并进行类型转换。请使用\set 元命令执行此操作：

```
\set canonical_literal '\'':result_text_typecast'\''::row_t
\echo :canonical_literal
```

\echo 元命令显示以下内容：

```
'(t,f,)'::row_t
```

接下来，使用规范文本更新“t.v2”，来确认行构造函数创建的值已被重新创建：

```
update t set v2 = :canonical_literal where k = 1;
select (v1 = v2)::text as "v1 = v2" from t where k = 1;
```

输出信息如下：

```
 v1 = v2
---------
 true
```

### “Row”类型的文本文字与“Row”类型的构造函数
类型构造函数和文本文字这两个概念在功能上有很大的不同。您可以使用DO块来演示差异，允许使用声明变量。使用SQL语句要付出更多的努力，因为您必须使用标量子查询来代替PL/pgSQL变量。ROW关键字在这里被故意省略，以强调其可选状态。

```
create type rt as (n numeric, s text, t timestamp, b boolean);
 
do $body$
declare
  n constant numeric := 42.17;
  s constant text := 'dog house';
  t constant timestamp := '2020-04-01 23:44:13';
  b constant boolean := true;
  r1 constant rt := (n, s, t, b)::rt;
  r2 constant rt := '(42.17,"dog house","2020-04-01 23:44:13",t)'::rt;
begin
  assert r1 = r2, 'unexpected';
end;
$body$;
```

## **“row”类型值数组的文本文字**

现在，您将如何为基本数据类型值数组编写文本文字，与如何为“row”类型值编写文本文字的理解结合起来。

### 规则声明
如果您遵循这里所述的规则，并进行说明，那么您将始终生成一个语法有效的文本。事实证明，许多其他变体，尤其是text[]值，是合法的，可以产生您想要的结果。然而，管理这些外来用途的规则不会被记录下来，因为以规范的形式创建文本文字已经足够了。
一般来说：

* 从左大括号开始。
* 首先，根据“row”类型值的文本文字中列出的规则，为每个“row”型值准备文本文字。
* 要明白，当这些在数组的文本中的“row”类型值的文本中使用时，“row”本身必须用双引号括起来，就像时间戳值或包含空格或其他麻烦字符的文本值的规则一样。
* “row”类型文字的括号内出现的任何双引号和反斜杠都必须再次转义：双引号变为反斜杠双引号；并且反斜杠变为反斜杠-反斜杠。 
* 为了避免错误地转义括起来的双引号，需要：
  进行内部转义
  用未转义的双引号将“row”类型值的完整表示形式括起来。 
* 最后用右大括号结束。 

### 示例
该示例使用了一个包含四个字段的“row”类型：一个int字段；一个text 字段；一个timestamp 字段；和一个boolean 字段。但要注意如下：
     \<space>     ,     (     )     "     \\

首先，创建“row”类型： 

接下来，创建一个具有数据类型为“rt”的列的表，填充六行数据，这些行在其文本字段中，使用上面列出的所有特别需要注意的字符：

```
create table t1(k int primary key, v rt);
```

最后，通过在DO块中，使用适当类型的PL/pgSQL变量，自下而上构建“row”类型值来填充表，并检查结果。这种技术允许为本演示选择的实际基本数据类型值，被单独看做是每个数据类型所需的普通SQL文字。这使得代码比任何其他方法都更可读、更易于理解。换句话说，它表明，对于人工编写的代码来说，任何复合值的值构造函数的可用性，都远大于产生相同值的文字的可用性。

```
do $body$
declare
  n1 constant int := 1;
  s1 constant text := ' ';
  t1 constant timestamp := '2091-01-20 12:10:05';
  b1 constant boolean := true;
 
  n2 constant int := 2;
  s2 constant text := ',';
  t2 constant timestamp := '2002-01-20 12:10:05';
  b2 constant boolean := false;
 
  n3 constant int := 3;
  s3 constant text := '(';
  t3 constant timestamp := '2003-01-20 12:10:05';
  b3 constant boolean := null;
 
  n4 constant int:= 4;
  s4 constant text := ')';
  t4 constant timestamp := '2004-01-20 12:10:05';
  b4 constant boolean := true;
 
  n5 constant int:= 5;
  s5 constant text := '"';
  t5 constant timestamp := '2005-01-20 12:10:05';
  b5 constant boolean := false;
 
  n6 constant int:= 6;
  s6 constant text := '\';
  t6 constant timestamp := '2006-01-20 12:10:05';
  b6 constant boolean := null;
begin
  insert into t1(k, v) values
    (1, (n1, s1, t1, b1)),
    (2, (n2, s2, t2, b2)),
    (3, (n3, s3, t3, b3)),
    (4, (n4, s4, t4, b4)),
    (5, (n5, s5, t5, b5)),
    (6, (n6, s6, t6, b6));
end;
$body$;
select v::text as lit from t1 order by k;
```

输出信息如下：

```
               lit
----------------------------------
 (1," ","2091-01-20 12:10:05",t)
 (2,",","2002-01-20 12:10:05",f)
 (3,"(","2003-01-20 12:10:05",)
 (4,")","2004-01-20 12:10:05",t)
 (5,"""","2005-01-20 12:10:05",f)
 (6,"\\","2006-01-20 12:10:05",)
```

int字段和timestamp字段是不起眼的，仅仅是为了满足规范形式的要求，时间戳值的表示必须是双引号的。布尔字段也不起眼，只要你记得NULL是通过在该字段周围的分隔符之间不留空格来表示的。这只留下文本字段供参考，以下是字段表示本身，没有分隔符的混乱：

​     " "     ","     "("     ")"     """"     "\\\\"

前四个并不起眼，只要你记得这四个单独的字符中的每一个，如开头所示，通常都必须用双引号括起来。则，只剩下最后两个：

* 源数据中出现的单双引号必须加倍，然后用双引号括起来。
* 源数据中出现的单个反斜杠必须加倍，然后用双引号括起来。

接下来，通过使用array_agg() 函数，将这六个“row”类型值拼接到一个数组值中，如下所示：

```
select array_agg(v order by k) from t1;
```

最后将此值插入到新表中，如下所示： 

```
create table t2(k int primary key, v1 rt[], v1_text_typecast text, v2 rt[]);
insert into t2(k, v1)
select 1, array_agg(v order by k) from t1;
```

您在前几节中使用的\get技术在这里是不可行的，因为它的大小有上限。因此，在这里，会将您通过文本类型转换“t2.v1”生成的文本插入到同一表中的“v1_text_typecast”字段中，如下所示：

```
update t2 set v1_text_typecast =
(select v1::text from t2 where k = 1);
```

最后，使用这个数组文字来重新创建原始值，并检查它是否与您开始使用的值相同。

```
update t2 set v2 =
(select v1_text_typecast from t2 where k = 1)::rt[];
 
select (v1 = v2)::text as "v1 = v2" from t2 where k = 1;
```

输出信息如下：

```
 v1 = v2
---------
 true
```

查看“row”类型值数组的文字：

```
select v1_text_typecast from t2 where k = 1;
```

返回信息如下：

```
{
  "(1,\"a \",\"2091-01-20 12:10:05\",t)",
  "(2,\", \",\"2002-01-20 12:10:05\",f)",
  "(3,\"( \",\"2003-01-20 12:10:05\",)",
  "(4,\" )\",\"2004-01-20 12:10:05\",t)",
  "(5,\"\"\"\",\"2005-01-20 12:10:05\",f)",
  "(6,\"\\\\\",\"2006-01-20 12:10:05\",)"
}
```

注意：为了便于阅读，这里，手动添加了空格。

### 用于为“row”类型值的一维数组生成文字的伪代码

这个伪代码显示了如何创建一个“row”类型值的数组文字，这些值的格式与上面示例中的“type rt”的格式相同。输入是任意数量的"(n, s, t, b)"。下面的文本是从实际工作和测试的Python代码中派生出来的。编写该代码是为了验证算法的正确性。
伪代码保留了Python语句，其含义足够清晰，可以对算法进行描述。各种特殊字符都被设置为具有自我描述名称的显式常量。
请注意，该算法在开头大括号之后、每个“row”类型值的成对表示之间，以及结尾大括号之前，插入一新行。虽然严格地说，这意味着它产生的文字不是规范形式的，但这没有任何影响。

```
"Start a new array literal":
  wip_literal = lft_crly_brace + nl
 
"For each next (n, s, t, b) tuple that defines a "row" type value":
  curr_rec = dbl_quote + lft_parens
 
  # Field "n" maps to a SQL numeric
  if n is None:
    curr_rec += comma
  else:
    curr_rec += (str(n) + comma)
 
  # Field "s" maps to a SQL text.
  if s is None:
    curr_rec += comma
  else:
    # First, do the escaping needed for any stringy value
    # as field in record literal value.
    s = s.replace(bk_slash, two_bk_slashes)
    s = s.replace(dbl_quote, two_dbl_quotes)
    s = dbl_quote + s + dbl_quote
 
    # Next, do the escaping to fix the bare record representation
    # for use as a array element.
    s = s.replace(bk_slash, two_bk_slashes)
    s = s.replace(dbl_quote, bk_slash_dbl_quote)
    curr_rec += (s + comma)
 
    # Field "t" maps to a SQL timestamp.
    if t is None:
      curr_rec += comma
    else:
      curr_rec += (bk_slash_dbl_quote + t + bk_slash_dbl_quote + comma)
 
    # Field "b" maps to a SQL boolean.
    # It's the last field, do nothing if it's neither "t" nor "f"
    if (b == "t" or b == "f"):
      curr_rec += b
 
  # Now there are no more inout tuples.
  curr_rec = curr_rec + rgt_parens + dbl_quote
  wip_literal = wip_literal + curr_rec + comma + nl
 
# Now there are no more input tuples.
"Finish off":
  # Remove the final (comma + nl), put the nl back,
  # and add the closing curly brace.
  wip_literal = wip_literal[:-2] + nl + rgt_crly_brace
```