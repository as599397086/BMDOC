这里列出的大多数函数和运算符可以使用任何维度的数组，但其中四个函数只接受或生成一维数组。当存在一维数组限制时，下表中的第二列“1-d only?”以“1-d”表示。否则为空，代表没有维度限制。

## **创建函数**

| 函数和运算符                             | 1-d only? | 描述                                                         |
| ---------------------------------------- | --------- | ------------------------------------------------------------ |
| [array[]](#_array[]构造函数)             |           | array[]值构造函数是一个特殊的函数，它使用每个数组值的表达式从头开始创建数组。表达式本身可以使用array[]构造函数或文本文字。 |
| [array_fill()](#_array_fill())           |           | 返回一个用指定值和维度初始化好的数组                         |
| [array_agg()](#_array_agg())             |           | 从SQL子查询返回一个数组（隐含的“row”类型）。                 |
| [string_to_array()](#_string_to_array()) | 1-d       | 通过使用指定的分隔符将输入文本值拆分为子值，返回一维text[]数组。（可选）允许将指定的文本值解释为NULL |

### array_fill()
目的：返回一个用指定值和维度初始化好的数组

用法：
输入值:       anyelement, int[] [, int[]]
返回值:      anyarray

第一个参数确定每个单元格的值和数据类型，从而确定整个新数组的数据类型。它可以是基本数据类型的值，也可以是“row”类型的值。出于某种目的，也可以写成行如NULL::some_type。您可能会设置NOT NULL值，例如，如果您想将数组插入到已创建约束的表列中，该约束基于PL/pgSQL函数，则该函数显式测试数组的几何属性，及其每个值的NOT NULL状态。示例如下：

```
select pg_typeof(array_fill(null::text, '{1}')) as "type of the new array";
```

返回信息如下：

```
 type of the new array
------------------------
 text[]
```

第二个参数是一个int[]数组。它的每个值都是array_length(new_arr，n)返回的值，其中“n”是从主维度开始的维度编号。因此，您在这里提供的数组的基数指定了array_ndims(new_arr)返回的值。
第三个参数是可选的。提供时，它必须是一个与第二个参数具有相同基数的int[]数组。它的每个值都指定array_lower(new_arr, n)返回的值。
因此，新数组的形状完全由第二和第三参数指定。 
注意：array_fill()为什么存在？换言之，为什么不直接为每个单元格建立索引，并为其分配你想赋予的值呢？回想一下，正如大纲中所描述的，数组值是线性的。这意味着，当其维度数超过一时，其形状在创建时是无法协商的。如下这个DO块强调了这一点。

```
do $body$
declare
  a int[];
  b int[] := array_fill(null::int, '{3, 4}');
begin
  a[1][1] := 42;
  begin
    -- Causes ERROR: array subscript out of range
    a[2][2] := 17;
  exception
    when array_subscript_error then null;
  end;
  raise info
    'cardinality(a), cardinality(b): %, %', cardinality(a), cardinality(b);
end;
$body$;
```

  返回信息如下（为方便阅读，手动去除了“INFO:”提示）：

```
  cardinality(a), cardinality(b): 1, 12
```

所以数组“a”被固定为一维的，一个接一个的值。

例如：
运行如下脚本：

```
create table t(k int primary key, arr text[]);
 
insert into t(k, arr)
values(1, array_fill('-----'::text, '{3, 4}', '{2, 7}')::text[]);
 
select
  array_length(arr, 1)  as len_1,
  array_length(arr, 2)  as len_2,
  array_lower(arr,  1)  as lb_1,
  array_lower(arr,  2)  as lb_2,
  array_ndims(arr)      as ndims,
  cardinality(arr)      as cardinality
from t
where k = 1;
```

返回信息如下：

```
 len_1 | len_2 | lb_1 | lb_2 | ndims | cardinality
-------+-------+------+------+-------+-------------
   3 |     4 |   2 |   7 |    2 |      12
```

接下来，运行如下：

```
update t
set
  arr[2][ 7] = '2---7',
  arr[2][10] = '2--10',
  arr[4][ 7] = '4---7',
  arr[4][10] = '4--10'
where k = 1;
select arr::text from t where k = 1;
```

返回信息如下（为方便阅读，手动增加了空格）：

```
[2:4][7:10]=
  {
    {2---7,-----,-----,2--10},
    {-----,-----,-----,-----},
    {4---7,-----,-----,4--10}
  }
```

最后，再运行如下：

```
\set VERBOSITY verbose
update t
set
  arr[1][17] = 'Hmm...'
where k = 1;
```

会报告如下错误信息：

```
2202E: array subscript out of range
```

### array_agg()
此函数有两个重载函数。
#### *array_agg() 重载函数一*

目的：从SQL子查询返回一维数组。它的行可能是标量（也就是说，SELECT列表可能是单列）。但是，一般情况下，可能是“row”类型的值。 

用法：
输入值:       SETOF anyelement
返回值:      anyarray

一般情况下，array_agg()是被应用于SELECT，从物理表或封装视图中进行查询。这在下面的示例中会被演示。但是，首先，您可以通过使用VALUES语句来演示该功能，而无需创建和填充表。示例如下：

```
values
  (1::int, 'dog'::text),
  (2::int, 'cat'::text),
  (3::int, 'ant'::text);
```

生成的结果为：

```
 column1 | column2
---------+---------
       1 | dog
       2 | cat
       3 | ant
```

请注意，BSQL已将SELECT列表项命名为“column1”和“column2”。其结果就是所谓的SETOF。它意味着一组行，就像使用SELECT语句产生的一样，如果用 \df 元命令描述generate_series()内置表函数，就会看到这个术语。要使用VALUES语句生成的行作为array_agg()的输入，需要使用命名类型，因此： 

```
create type rt as (f1 int, f2 text);
 
with tab as (
  values
    (1::int, 'dog'::text),
    (2::int, 'cat'::text),
    (3::int, 'ant'::text))
select array_agg((column1, column2)::rt order by column1) as arr
from tab;
```

返回信息如下：

```
               arr
---------------------------------
 {"(1,dog)","(2,cat)","(3,ant)"}
```

您可以这样理解array_agg()：

* 将每一行视为具有单个值的 “rt[]” 数组。
* 将所有行中的值按指定顺序连接到一个新的 “rt[]” 数组中。

下面代码说明了这一点：

```
-- Consider this SELECT:
with tab as (
  values
    ((1, 'dog')::rt),
    ((2, 'cat')::rt),
    ((3, 'ant')::rt))
select array_agg(column1 order by column1) as arr
from tab;
 
-- It can be seen as equivalent this SELECT:
select
  array[(1, 'dog')::rt] ||
  array[(2, 'cat')::rt] ||
  array[(3, 'ant')::rt]
as arr;
```

上面三个“select…as arr”查询中的每一个都会产生相同的结果，证明了它们在语义上的等价性。

要准备unnest()的演示，请使用 \gset 元命令将三个查询中最近一个查询的单值结果（其中任何一个都可以）保存到bsqlsh变量中。这需要一个单独的参数，通常会加下划线（例如，“result_”），并重新运行SELECT语句，该语句作为最后提交的bsqlsh命令，仍在命令缓冲区中。如果SELECT不是返回单行，则会得到一个明显的错误。通常，当SELECT列表有N个成员，称为“c1”到“cN”，这些值中的每一个都存储在自动创建的变量中，称为”result_c1“到”result_cN“。 

在运行上面的“with…select array_agg（…）as arr…”查询后，立即执行以下操作：

```
\gset result_
\echo :result_arr
```

\echo 元命令显示以下内容：

```
{"(1,dog)","(2,cat)","(3,ant)"}
```

#### *array_agg() 重载函数二*
目的：从行为N维数组的SQL子查询，返回一个（N+1）维数组。聚合数组必须都具有相同的维度。

用法：

输入值:      SETOF anyarray
返回值:      anyarray

示例如下：

```
with tab as (
  values
    ('{a, b, c}'::text[]),
    ('{d, e, f}'::text[]))
select array_agg((column1)::text[] order by column1) as arr
from tab;
```

生成如下结果：

```
        arr
-------------------
 {{a,b,c},{d,e,f}}
```

如下是一个不可用的示例：

```
with tab as (
  values
    ('{a, b, c}'::text[]),
    ('{d, e   }'::text[]))
select array_agg((column1)::text[] order by column1) as arr
from tab;
```

会报告如下错误信息：

```
2202E: cannot accumulate arrays of different dimensionality
```

### string_to_array()
目的：通过使用指定的文本值作为“分隔符”，将输入文本值拆分为子值，返回一维text[] 数组。（可选）允许将指定的文本值解释为NULL。

用法：

输入值:      text, text [, text]
返回值:      text[]

示例如下：

```
select string_to_array(
  'a|b|?|c', -- the to-be-split string
  '|',       -- the character(s) to be taken as the delimiter
  '?'        -- the character(s) to be taken to the null indicator
) as "string_to_array result";
```

返回信息如下：

```
 string_to_array result
------------------------
 {a,b,NULL,c}
```

语法：
“分隔符”和“null指示符”，使用以下优先级规则：“分隔符”优先于“null指示符”。 
然而，只有当这两个由多个字符定义时，以及当其中一个以序列开头而另一个以顺序结尾时，此规则才重要。

因此，AiSQL建议，就像上面的示例一样，当选择“分隔符”和“null指示符”的文本值时，可以选择两个不同的单个字符。当然，您必须确保在要转换为text[]数组的任何文本值中都不会出现这两个值。

下面的DO块演示了一个不恰当的选择示例：

* “分隔符”为 ' !'::text
* “null指示符”是 '~ '::text。 

```
do $body$
declare
  delim_text  constant text := ' !';
  null_text   constant text := '~ ';
 
  input_text  constant text := 'dog house !~  !x! ~ ! cat flap !  !';
 
  result constant text[] :=
    string_to_array(input_text, delim_text, null_text);
 
  good_delim_text constant text := '|';
  good_null_text  constant text := '?';
 
  delim_first_text constant text :=
    replace(replace(
      input_text,
      delim_text, good_delim_text),
      null_text,  good_null_text);
 
  null_first_text constant text :=
    replace(replace(
      input_text,
      null_text,  good_null_text),
      delim_text, good_delim_text);
 
  delim_first_result constant text[] :=
    string_to_array(delim_first_text, good_delim_text, good_null_text);
 
  null_first_result constant text[] :=
    string_to_array(null_first_text, good_delim_text, good_null_text);
 
  -- Notice that one of the special characters, "!", remains in
  -- both expected_result and unexpected_result.
  -- If
  expected_result constant text[] :=
    '{"dog house",NULL,"x! ~"," cat flap"," ",""}';
  unexpected_result constant text[] :=
    '{"dog house",NULL,"x! ?! cat flap"," ",""}';
 
begin
  assert
  (result             =  expected_result)    and
  (delim_first_result =  expected_result)    and
  (null_first_result  <> delim_first_result) and
  (null_first_result  =  unexpected_result)  and
    true,
  'unexpected';
end;
$body$;
```

## **几何函数**

| 函数                               | 1-d only? | 描述                                                         |
| ---------------------------------- | --------- | ------------------------------------------------------------ |
| [array_ndims()](#_array_ndims())   |           | 返回数组的维度数                                             |
| [array_lower()](#_array_lower())   |           | 返回指定数组沿指定维度的下界                                 |
| [array_upper()](#_array_upper())   |           | 返回指定数组沿指定维度的上界                                 |
| [array_length()](#_array_length()) |           | 返回指定数组沿指定维度的长度                                 |
| [cardinality()](#_cardinality())   |           | 返回数组中元素的总数，如果数组为空则返回 0                   |
| [array_dims()](#_array_dims())     |           | 返回数组的维度的文本表示，对于所有维度，在单个文本值中返回与array_lower（）和array_length（）相同信息的文本表示形式。 |

本节函数示例均使用如下表及其相关数据：

```
create table t(k int primary key, arr_1 text[], arr_2 text[]);
insert into t(k, arr_1, arr_2) values(1,
      '[3:10]={ 1, 2, 3, 4,   5, 6, 7, 8}',
  '[2:3][4:7]={{1, 2, 3, 4}, {5, 6, 7, 8}}'
  );
```

### array_ndims()
目的：返回指定数组的维数（即维度）。

用法：

输入值:       anyarray
返回值:      int

示例如下：

```
select
  array_ndims(arr_1) as ndims_1,
  array_ndims(arr_2) as ndims_2
from t where k = 1;
```

返回信息如下：

```
  ndims_1 | ndims_2
---------+---------
       1 |       2
```

### array_lower()
目的：返回指定数组沿指定维度的下界。

用法：

输入值:       anyarray, int
返回值:      int


示例如下：

```
select
  array_lower(arr_1, 1) as arr_1_lb,
  array_lower(arr_2, 1) as arr_2_lb_1,
  array_lower(arr_2, 2) as arr_2_lb_2
from t where k = 1;
```

返回信息如下：

```
 arr_1_lb | arr_2_lb_1 | arr_2_lb_2
----------+------------+--------------
       3 |        2 |        4
```

### array_upper()
目的：返回指定数组沿指定维度的上界。

用法：

输入值:       anyarray, int
返回值:      int

示例如下：

```
select
  array_upper(arr_1, 1) as arr_1_ub,
  array_upper(arr_2, 1) as arr_2_ub_1,
  array_upper(arr_2, 2) as arr_2_ub_2
from t where k = 1;
```

返回信息如下：

```
 arr_1_ub | arr_2_ub_1 | arr_2_ub_2
----------+------------+----------------
       10 |        3 |        7
```

### array_length()
目的：返回指定数组沿指定维度的长度

用法：

输入值:       anyarray, int
返回值:      int

示例如下：

```
select
  array_length(arr_1, 1) as arr_1_len,
  array_length(arr_2, 1) as arr_2_len_1,
  array_length(arr_2, 2) as arr_2_len_2
from t where k = 1;
```

返回信息如下：

```
 arr_1_len | arr_2_len_1 | arr_2_len_2
-----------+-------------+----------------
        8 |         2 |         4
```

### cardinality()
目的：返回数组中元素的总数，如果数组为空则返回 0。请注意，此函数返回的值可以计算为array_length()函数的每一个维度返回的值的乘积。 

用法：

输入值:       anyarray
返回值:      int

示例如下：

```
select
  cardinality(arr_1) as card_1,
  cardinality(arr_2) as card_2
from t where k = 1;
```

返回信息如下：

```
 card_1 | card_2
--------+--------
      8 |    8
```

### array_dims()
目的：返回数组的维度的文本表示，对于所有维度，在单个文本值中返回与array_lower（）和array_length（）相同信息的文本表示形式。


用法：

输入值:       anyarray
返回值:      text

示例如下：

```
select
  array_dims(arr_1) as arr_1_dims,
  array_dims(arr_2) as arr_2_dims
from t where k = 1;
```

返回信息如下：

```
 arr_1_dims | arr_2_dims
------------+------------
 [3:10]     | [2:3][4:7]
```

## **查找函数**

| 函数                                     | 1-d only? | 描述                                                         |
| ---------------------------------------- | --------- | ------------------------------------------------------------ |
| [array_position()](#_array_position())   | 1-d       | 在提供的数组中返回指定值的索引。（可选）在指定索引处开始搜索。 |
| [array_positions()](#_array_positions()) | 1-d       | 在提供的数组中，返回所有出现指定值的索引                     |

这些函数要求要搜索的数组是一维的。它们返回指定要搜索数组中指定要搜索值的索引值。
本节函数示例均使用如下自定义函数：

```
drop function if exists arr() cascade;
create function arr()
  returns text[]
  language sql
as $body$
  select array[
                'mon', 'tue', 'wed', 'thu','fri', 'sat', 'sun', 
                'mon', 'tue', 'wed', 'thu','fri', 'sat', 'sun',
                'mon', 'tue', 'wed'
              ];
$body$;
```


按索引号列出days_arr列的元素，使用内置函数generate_subscripts（）。

```
with c(days, pos) as (
  select a, subscripts.pos
  from arr() as a
  cross join lateral
  generate_subscripts(arr(), 1) as subscripts(pos))
select pos, days[pos] as day from c order by pos;
```

返回信息如下：

```
 pos | day 
-----+-----
   1 | mon
   2 | tue
   3 | wed
   4 | thu
   5 | fri
   6 | sat
   7 | sun
   8 | mon
   9 | tue
  10 | wed
  11 | thu
  12 | fri
  13 | sat
  14 | sun
  15 | mon
  16 | tue
  17 | wed
```

### array_position()
目的：在提供的数组中返回指定值的索引。（可选）在指定索引处开始搜索。

用法：

输入值:       anyarray, anyelement [, int]
返回值:      int

注：第三个参数是可选的，包含指定的开始搜索的索引值。

示例如下：

```
select array_position(
    arr(),        -- The to-be-searched array.
    'tue'::text,  -- The to-be-searched-for value.
    3::int        -- The (inclusive) position
                  --   at which to start searching. [optional]
  ) as position;
```

返回信息如下：

```
 position 
-----------
      9
```

### array_positions()
目的：在提供的数组中，返回所有出现指定值的索引

用法：

输入值:       anyarray, anyelement
返回值:      integer[]

示例如下：

```
select unnest(
  array_positions(
      arr(),       -- The to-be-searched array.
      'tue'::text  -- The to-be-searched-for value.
    )
  ) as position;
```

返回信息如下：

```
 position 
-----------
      2
      9
     16
```

## **ANY/ALL运算符**

这些运算符要求LHS是标量，RHS是该LHS数据类型的数组
注：LHS代表操作符的左边，RHS代表操作符的右边，下文中，如未做特殊说明，LHS，RHS均代表此意义。

| 运算符            | 1-d only? | 描述                                                         |
| ----------------- | --------- | ------------------------------------------------------------ |
| [ANY](#_ANY和ALL) |           | 如果LHS元素和RHS数组的每个元素之间，至少有一个指定的不等式测试结果为TRUE，则返回TRUE。 |
| [ALL](#_ANY和ALL) |           | 如果LHS元素和RHS数组的每个元素之间，每个指定不等式测试的结果均为TRUE，则返回TRUE。 |

### ANY 和 ALL
ANY和ALL运算符中的每一个都具有相同的用法。
#### *概述*
注意：SOME是ANY的同义词。

用法：

输入值:       anyelement, anyarray
返回值:      boolean

这些运算符中的每一个都要求LHS表达式所计算的元素值的数据类型，与RHS表达式所计算的数组值的数据类型相对应。例如，当LHS元素的数据类型为“t”时，RHS数组的数据类型必须为“t[]”。RHS数组可以具有任何维度。运算符对数组中的实际元素是敏感的。

目的：
根据指定的一组比较的结果，返回TRUE、FALSE或NULL。如下是调用的一般形式：

```
any_all_boolean_expression ::=
  lhs_element { = | <> | < | <= | >= | > } { ANY | ALL} rhs_array
```

注意：!= 从等式和不等式运算符列表中省略，因为这只是 <> 不等式运算符的另一种拼写形式。 

因为“any_all_boolean_expression”只是一个布尔表达式，它可以选择性地在前面加上NOT一元运算符，并且可以以正常方式使用AND和OR与其他布尔表达式相结合使用。
“any_all_boolean_expression”依次访问数组的每个元素（如前所述，数组的维度无关紧要），并在LHS元素和当前数组元素之间，进行相等或不相等的比较。

#### *用途*
ANY和ALL是互补的。
注意，元素和数组的使用（在关于ANY和AND的整个部分中）指出了一个事实，就是LHS和RHS通常都是表达式。所以元素充当LHS表达式计算值的简写，数组充当RHS表达式计算值的简写。
分为简单场景与特别需求场景解释如下：
1）简单的场景
简单的场景仅限于LHS元素为NOT NULL、RHS数组为NOT NULL，并且RHS数组的基数至少为1的情况。

当LHS元素与RHS数组的每个元素进行比较时，这个比较会使用在“any_all_boolean_expression”中使用的特定等式或不等式运算符的适当的数据类型重载。

* 如果使用了ANY，则只有在连续比较中，至少有一个对比结果为TRUE时，最终结果才为TRUE。如果其他比较中有零个，或多个对比结果为NULL，也并并不会有任何的影响。如果每个比较的结果都为FALSE，则最终结果为FALSE。如果每个比较的计算结果都为NULL，则结果为NULL。
* 如果使用了ALL，则只有当每个连续比较的求值结果为TRUE时，结果才为TRUE。如果至少有一个比较结果为FALSE，而没有一个结果为NULL，则结果为FALSE；如果至少有一个比较结果为NULL，则结果为NULL。

请注意，ANY与OR类似，ALL与AND 类似：

* 如果使用ANY，则结果是连续的单个比较的OR组合。
* 如果使用ALL，则结果是连续的单个比较的AND组合。

下面这个DO块演示了如何使用OR和AND：

```
do $body$
begin
  -- OR
  assert     (true  or  false or  null),             'assert failed';
  assert     not (false or  false or  false),          'assert failed';
  assert     (false or  false or  null)   is null,     'assert failed';
 
  -- AND
  assert     (true  and true  and true),            'assert failed';
  assert     not (true  and true  and false),         'assert failed';
  assert     (true  and true  and null)   is null,     'assert failed';
end;
$body$;
```

下一个DO块是对块的手动重写，它演示了OR和AND的用途，也相应地展示了ANY和ALL的语义。

```
do $body$
begin
  -- ANY
  assert     (true = any (array[true,  false, null ]::boolean[])),         'assert failed';
  assert not (true = any (array[false, false, false]::boolean[])),         'assert failed';
  assert     (true = any (array[false, false, null ]::boolean[])) is null, 'assert failed';
 
  -- ALL
  assert     (true = all (array[true,  true,  true ]::boolean[])),         'assert failed';
  assert not (true = all (array[true,  true,  false]::boolean[])),         'assert failed';
  assert     (true = all (array[true,  true,  null ]::boolean[])) is null, 'assert failed';
end;
$body$;
```

= ANY在功能上等同于IN（但当RHS是数组时，IN是非法语法），而 =ALL在功能上没有类似等价的。
例如如下示例：

```
select (
    42 = any (array[17, 42, 53])
    and
    42 in (17, 42, 53)
  )::text as b;
```

返回信息如下：

```
  b
------
 true
```

注意，在这里，“（17，42，53）”不是一个结构化记录，因为在它前面加了IN。相反，在下面的示例中，“（17,42,53）”是一个结构化记录：

```
with v as (select (17, 42, 53) as r)
select pg_typeof(r)::text from v;
```

返回信息如下：

```
 pg_typeof
-----------
 record
```

由于直接使用“（17，42，53）”作为SELECT列表项。因此，如下会导致语法错误：

```
with v as (select (1, 2, 3, 4) as r)
select 1 in r from v;
```

2）特别需求场景
本小节解释如下：当LHS元素和RHS数组中的一个，或全部为NULL时；当LHS或RHS都不为NULL，并且RHS数组的基数为零时。

* 如果LHS元素或RHS数组为NULL，则ANY结果为NULL，ALL结果也为NULL。
* 如果LHS元素不是NULL，RHS数组不是NULL，并且RHS数组有零个元素，那么ANY结果为FALSE。
* 如果LHS元素不是NULL，RHS数组不是NULL，并且RHS数组有零个元素，则ALL结果为TRUE。 

#### *示例*
以下示例显示了单元素数组、复合元素数组和DOMAIN值元素数组的使用。
1）单元素数组

```
do $body$
declare
  v1 constant int := 1;
  v2 constant int := 2;
  v3 constant int := 3;
  v4 constant int := 4;
  v5 constant int := 5;
  v6 constant int := null;
 
  arr1 constant int[] := array[v1, v1, v1, v1];
  arr2 constant int[] := array[v1, v1, v1, v2];
  arr3 constant int[] := array[v1, v2, v3, v4];
  arr4 constant int[] := array[v1, v1, v1, null];
  arr5 constant int[] := null;
 
  -- Notice that an array with zero elements is nevertheless NOT NULL.
  arr6 constant int[] not null := '{}';
 
  b01 constant boolean not null :=     v1 = all (arr1);
  b02 constant boolean not null := not  v1 = all (arr3);
  b03 constant boolean not null := not  v1 = all (arr2);
  b04 constant boolean not null :=     v1 = any (arr3);
  b05 constant boolean not null := not  v5 = any (arr3);
 
  b06 constant boolean not null :=      v1 = any (arr4);
  b07 constant boolean not null :=     (v5 = any (arr4)) is null;
  b08 constant boolean not null :=     (v1 = all (arr4)) is null;
 
  b09 constant boolean not null :=     (v1 = any (arr5)) is null;
  b10 constant boolean not null :=     (v6 = any (arr1)) is null;
  b11 constant boolean not null :=     (v1 = all (arr5)) is null;
  b12 constant boolean not null :=     (v6 = all (arr1)) is null;
 
  b13 constant boolean not null :=  not (v1 = any (arr6));
  b14 constant boolean not null :=     (v1 = all (arr6));
begin
  assert
    (b01 and b02 and b03 and b04 and b05 and b06 and b07 and b08
         and b09 and b10 and b11 and b12 and b13 and b14),
  'assert failed';
end;
$body$;
```

下面是一个从上面的代码中派生的示例，它使用二维数组代替一维数组。但为了提高可读性，删除了一些测试。其余测试的结果没有变化，因为这些结果仅取决于数组的实际元素，而不取决于其几何结构。

```
do $body$
declare
  v1 constant int := 1;
  v2 constant int := 2;
  v3 constant int := 3;
  v4 constant int := 4;
  v5 constant int := 5;
 
  arr1 constant int[] := array[array[v1, v1], array[v1, v1]];
  arr2 constant int[] := array[array[v1, v2], array[v3, v4]];
  arr3 constant int[] := array[array[v1, v1], array[v1, null]];
 
  b1 constant boolean not null :=     v1 = all (arr1);
  b2 constant boolean not null := not  v1 = all (arr2);
  b3 constant boolean not null :=     v1 = any (arr2);
  b4 constant boolean not null := not  v5 = any (arr2);
 
  b5 constant boolean not null :=     v1 = any (arr3);
  b6 constant boolean not null :=     (v5 = any (arr3)) is null;
  b7 constant boolean not null :=     (v1 = all (arr3)) is null;
begin
  assert
    (b1 and b2 and b3 and b4 and b5 and b6 and b7),
  'assert failed';
end;
$body$;
```

2）复合元素数组（row类型）
该代码是通过将int替换为“rt”，并相应地更改了给“v1”到“v5”的值分配。同样，为了提高可读性，删除了一些测试。其余代码的其余部分与第一个示例中的对应代码相同。

```
drop type if exists rt;
create type rt as (a int, b text);
 
do $body$
declare
  v1 constant rt := (0, 1);
  v2 constant rt := (2, 3);
  v3 constant rt := (4, 5);
  v4 constant rt := (6, 7);
  v5 constant rt := (8, 9);
 
  arr1 constant rt[] := array[v1, v1, v1, v1];
  arr2 constant rt[] := array[v1, v2, v3, v4];
  arr3 constant rt[] := array[v1, v1, v1, null::rt];
 
  b1 constant boolean not null :=     v1 = all (arr1);
  b2 constant boolean not null := not v1 = all (arr2);
  b3 constant boolean not null :=     v1 = any (arr2);
  b4 constant boolean not null := not v5 = any (arr2);
 
  b5 constant boolean not null :=     v1 = any (arr3);
  b6 constant boolean not null :=    (v5 = any (arr3)) is null;
  b7 constant boolean not null :=    (v1 = all (arr3)) is null;
begin
  assert
    (b1 and b2 and b3 and b4 and b5 and b6 and b7),
  'assert failed';
end;
$body$;
```

3）DOMAIN值元素数组
首先，考虑以下两个示例：

```
drop domain if exists d1_t;
create domain d1_t as int
default 42 constraint d1_t_chk check(value >= 17);
 
drop domain if exists d2_t;
create domain d2_t as int[];
```


很明显，“d1_t”的值，是int的一种特殊类型。但是“d2_t”的值呢？是一种特殊的数组？最重要的是，“d2_t”不符合任意数组的条件，相反，它符合任何元素的条件。此代码示例强调了这一点：

```
create or replace procedure p(i in anyelement)
  language plpgsql
as $body$
begin
  raise info '%', pg_typeof(i);
end;
$body$;
 
call p(53::d1_t);
 
call p('{1, 2}'::d2_t);
```

第一个call，返回如下信息：

```
INFO:  d1_t
```

第二个call，返回如下信息：

```
INFO:  d2_t
```

再次修改代码，用“int_arr_t”替换，相应地更改了“v1”到“v5”的值分配。同样，为了提高可读性，删除了一些测试。其余代码的其余部分与第一个示例中的对应代码相同。

```
drop domain if exists int_arr_t;
create domain int_arr_t as int[];
 
do $body$
declare
  v1 constant int_arr_t := array[1, 1];
  v2 constant int_arr_t := array[2, 3];
  v3 constant int_arr_t := array[4, 5];
  v4 constant int_arr_t := array[5, 7];
  v5 constant int_arr_t := array[8, 9];
 
  arr1 constant int_arr_t[] := array[v1, v1, v1, v1];
  arr2 constant int_arr_t[] := array[v1, v2, v3, v4];
  arr3 constant int_arr_t[] := array[v1, v1, v1, null::int_arr_t];
 
  b1 constant boolean not null :=     v1 = all (arr1);
  b2 constant boolean not null := not v1 = all (arr2);
  b3 constant boolean not null :=     v1 = any (arr2);
  b4 constant boolean not null := not v5 = any (arr2);
 
  b5 constant boolean not null :=     v1 = any (arr3);
  b6 constant boolean not null :=    (v5 = any (arr3)) is null;
  b7 constant boolean not null :=    (v1 = all (arr3)) is null;
begin
  assert
    (b1 and b2 and b3 and b4 and b5 and b6 and b7),
  'assert failed';
end;
$body$;
```

4）数组的元素彼此相同的测试
这个示例，展示了数组的元素是否彼此相同的测试，而不需要知道它们的值或数组维度的任何信息。

```
do $body$
declare
  arr constant int[] not null := '
    [2:3][4:6][7:10]={
      {
        {42,42,42,42},{42,42,42,42},{42,42,42,42}
      },
      {
        {42,42,42,42},{42,42,42,42},{42,42,42,42}
      }
    }'::int[];
 
   val constant int not null := (
    select unnest(arr) limit 1);
 
  b99 boolean not null := val = all (arr);
begin
  assert b99, 'assert failed';
end;
$body$;
```

5）使用不等式的比较

```
do $body$
declare
  v1 constant int := 1;
  v2 constant int := 2;
  v3 constant int := 3;
  v4 constant int := 4;
  v5 constant int := 5;
 
  arr1 constant int[] := array[v1, v2, v3, v4];
 
  b01 constant boolean not null := not (v5  = any (arr1));
  b02 constant boolean not null :=    v5 <> all (arr1);
  b03 constant boolean not null :=    v2  > any (arr1);
  b04 constant boolean not null := not (v2  > all (arr1));
  b05 constant boolean not null := not (v4  < any (arr1));
  b06 constant boolean not null :=    v2  < any (arr1);
  b07 constant boolean not null := not (v5 <= any (arr1));
  b08 constant boolean not null :=    v4 >= all (arr1);
  b09 constant boolean not null :=    v5  > all (arr1);
 
begin
  assert
    (b01 and b02 and b03 and b04 and b05 and b06 and b07 and b08 and b09),
  'assert failed';
end;
$body$;
```

## **比较运算符**

| 运算符 | 1-d only? | 描述                                                         |
| ------ | --------- | ------------------------------------------------------------ |
| =      |           | 如果LHS和RHS数组相等，则返回TRUE。                           |
| <>     |           | 如果LHS和RHS数组不相等，则返回TRUE。                         |
| >      |           | 如果LHS数组大于RHS数组，则返回TRUE。                         |
| >=     |           | 如果LHS数组大于或等于RHS数组，则返回TRUE。                   |
| <=     |           | 如果LHS数组小于或等于RHS数组，则返回TRUE。                   |
| <      |           | 如果LHS数组小于RHS数组，则返回TRUE。                         |
| @>     |           | 如果LHS数组包含RHS数组，也就是说，如果在LHS数组的不同值中找到RHS数组中的每个不同值，则返回TRUE。 |
| <@     |           | 如果RHS数组包含LHS数组，也就是说，如果在RHS数组的不同值中找到LHS数组中的每个不同值，则返回TRUE。 |
| &&     |           | 如果LHS和RHS数组重叠，即如果它们至少有一个共同值，则返回TRUE |

### 概述

目的：每个比较运算符，根据LHS和RHS数组之间的特定比较测试的结果，返回TRUE或FALSE。

用法：这些操作符具有相同的用法

输入值:       anyarray, anyarray
返回值:      boolean

注意：这些运算符要求LHS和RHS数组具有相同的数据类型。这是标量比较的相同规则。然而，它们并不要求数组具有相同的几何属性。规则定义，属性中的一个，或多个之间的差异，并不意味着不允许进行比较。相反，LHS数组可能被认为小于，或大于RHS数组。因此，理解比较算法是至关重要的。

比较标准
这些是比较两个数组值的算法的独特特征：

* 实际值，按行主顺序成对比较
* 基数
* 维度的数量
* 每个维度上的下界。

在这些比较中有一个明确的优先次序。简单地说，首先进行值比较。然后，只有在没有检测到差异的情况下，才进行几何特性的比较。

值的成对比较
第一个比较测试，按行主顺序扫描每个LHS和RHS数组中的值，并进行成对比较。值得注意的是，当非null数组值，与null值成对比较时，非null值被认为小于null值。

### 示例
1）= 和 <>  操作符

* 如果LHS和RHS数组相等，则 = 运算符返回TRUE。
* 如果LHS和RHS数组不相等，则 <> 运算符返回TRUE。 

= 运算符的示例：

```
with
  v as (
    select
      (select array['a', 'b', null, 'd']::text[]) as a1,
      (select      '{a,   b,  null,  d}'::text[]) as a2
  )
select (a1 = a2)::text as "EQUALITY comparison result"
from v;
```

返回信息如下：

```
 EQUALITY comparison result
----------------------------
 true
```

<> 运算符的示例：

```
with
  v as (
    select
      (select array['a', 'b', 'c',  'd']::text[]) as a1,
      (select      '{a,   b,  null,  d}'::text[]) as a2
  )
select (a1 <> a2)::text as "INEQUALITY comparison result"
from v;
```

返回信息如下：

```
 INEQUALITY comparison result
------------------------------
 true
```

2） > 与 >= 与 <= 与 < 操作符
这四个运算符实现了常见的不等式比较 

* 如果LHS数组大于RHS数组，则 > 运算符返回TRUE。
* 如果LHS数组大于或等于RHS数组，则 >= 运算符返回TRUE。
* 如果LHS数组小于或等于RHS数组，则 <= 运算符返回TRUE。
* 如果LHS数组小于RHS数组，则 < 运算符返回TRUE。
  下面仅仅给出 < 运算符的示例：

```
with
  v as (
    select
      (select array['a', 'b', 'c',  'd']::text[]) as a1,
      (select array['a', 'b', 'e',  'd']::text[]) as a2,
      (select      '{a,   b,  null,  d}'::text[]) as a3
  )
select
  (a1 < a2)::text as "'LESS THAN' comparison result 1",
  (a1 < a3)::text as "'LESS THAN' comparison result 2"
from v;
```

返回信息如下：

```
 'LESS THAN' comparison result 1 | 'LESS THAN' comparison result 2
------------------------------------------+---------------------------------------------
 true                         | true
```

3） @> 与 <@ 操作符
如果LHS数组包含RHS数组，也就是说，如果RHS数组中的每个不同值都是在LHS数组的不同值中找到的，则 @> 运算符返回TRUE；反之，则 <@ 运算符返回TRUE。 

```
with
  v as (
    select
      (select array['a', 'b', 'c',  'd']::text[]) as a1,
      (select array['a',      'c'      ]::text[]) as a2
  )
select
  (a1 @> a2)::text as "CONTAINS comparison result",
  (a2 <@ a1)::text as "'IS CONTAINED BY' comparison result"
from v;
```

返回信息如下：

```
 CONTAINS comparison result | 'IS CONTAINED BY' comparison result
----------------------------------------+-------------------------------------------------
 true                       | true
```

4）&& 运算符
如果LHS和RHS数组至少有一个共同值，则 && 运算符返回TRUE。

```
with
  v as (
    select
      (select array['a', 'b', 'c',  'd']::text[]) as a1,
      (select array['d', 'e', 'f',  'g']::text[]) as a2
  )
select
  (a1 && a2)::text as "'a1 OVERLAPS a2' comparison result",
  (a2 && a1)::text as "'a2 OVERLAPS a1' comparison result"
from v;
```

返回信息如下：

```
 'a1 OVERLAPS a2' comparison result | 'a2 OVERLAPS a1' comparison result
------------------------------------------------+----------------------------------------------
 true                            | true
```

5）以下是两个完整的示例

示例1：

```
-- Any two arrays can be compared without error if they have the same data type.
do $body$
begin
  ------------------------------------------------------------------------------
  -- Illustrate "IS NOT DISTINCT FROM" semantics.
  declare
    v1 constant int := 1;
    v2 constant int := 1;
    n1 constant int := null;
    n2 constant int := null;
  begin
    assert
      (v1 = v2)                    and
      (v1 is not distinct from v2) and
 
      ((n1 = n2) is null)          and
      (n1 is not distinct from n2),
    'unexpected';
  end;
 
  ------------------------------------------------------------------------------
  -- Basic demonstration of equaliy when the geom. properties of
  -- the two arrays are identical.
  -- Shows that pairwise comparison uses "IS NOT DISTINCT FROM" semantics and NOT
  -- the conventional NULL semantics used when scalars are compared.
  declare
    a constant int[] := '{10, null, 30}';
    b constant int[] := '{10, null, 30}'; -- Identical to a.
  begin
    assert
      (a = b),
    '"a = b" assert failed';
 
    -- Because of this, there's no need ever to write this.
    assert
      (a is not distinct from b),
    '"a is not distinct from b" assert failed';
  end;
 
  ------------------------------------------------------------------------------
  -- Basic demonstration of inequality when the geometric properties of
  -- the two arrays are identical.
  -- When the first difference is encountered in row-major order, the comparison
  -- is made. Other differences are irrelevant.
  declare
    a constant int[] := '{10, 20, 30}';
    b constant int[] := '{10, 19, 31}';
  begin
    assert
      (a <> b) and
      (a >  b) and
      (a >= b) and
      (b <= a) and
      (b <  a) ,
    '"a > b" assert failed';
  end;
 
  ------------------------------------------------------------------------------
  -- Demonstration of inequality when the geometric properties of
  -- the two arrays are identical.
  -- Here, the first pairwise difference is NOT NULL versus NULL.
  declare
    a constant int[] := '{10, 20,   30}';
    b constant int[] := '{10, null, 29}';
  begin
    -- Bizarrely, a NOT NULL value counts as LESS THAN a NULL value in the
    -- pairwise comparison.
    assert
      (a <> b) and
      (a <  b),
    '"a < b" assert failed';
 
    -- Again, because of this, there's no need ever to write this.
    assert
      (a is distinct from b) ,
    '"a is distinct from b" assert failed';
  end;
 
  ------------------------------------------------------------------------------
  -- Extreme demonstration of priority.
  -- c has just a single value and d has several.
  -- c has one dimension and d has two.
  -- c's first lower bound is less than d's first lower.
  -- d's second lower bound is greater than one, but is presumably irrelevant.
  -- But c's first value is GREATER THAN d's first value,
  -- scanning in row-major order.
  --
  -- Pairwise value comparison has the hoghest priority.
  -- therefore c is deemed to be GREATER THAN d.
 
  declare
    c constant int[] := '{2}';
 
    -- Notice that d's first value is at [2][3].
    d constant int[] := '[2:3][3:4]={{1, 2}, {3, 3}}';
 
  begin
    assert
      cardinality(c) < cardinality(d),
    '"cardinality(c) < cardinality(d)" assert failed';
 
    assert
      array_ndims(c) < array_ndims(d),
    '"ndims(c) < ndims(d)" assert failed';
    assert
      array_lower(c, 1) < array_lower(d, 1),
    '"lower(c, 1) < lower(d, 1)" assert failed';
 
    assert
      c[1] > d[2][3],
    '"c[1] > d[2][3]" assert failed';
 
   assert
     c > d,
   '"c > d" assert failed';
  end;
 
  ------------------------------------------------------------------------------
  -- Pairwise comparison is equal are far as it is feasible.
  -- e's ndims < f's.
  -- e's lb-1 < f's.
  -- BUT e's cardinality > f's.
  -- Cardinality has highest priority among the geom. propoerties,
  -- so e is deemed to be GREATER THAN f.
  declare
    e constant int[] := '{10, 20, 30, 40, 50, 60, 70}';
    f constant int[] := '[2:3][3:5]={{10, 20, 30}, {40, 50, 60}}';
  begin
    assert
      e[1] = f[2][3] and
      e[2] = f[2][4] and
      e[3] = f[2][5] and
      e[4] = f[3][3] and
      e[5] = f[3][4] and
      e[6] = f[3][5] ,
    '"e-to-f" eqality test, as far as feasible, assert failed';
 
    assert
      array_ndims(e) < array_ndims(f),
    '"ndims(e) < ndims(f)" assert failed';
 
    assert
      array_lower(e, 1) < array_lower(f, 1),
    '"lower(e, 1) < lower(f, 1)" assert failed';
 
    assert
      cardinality(e) > cardinality(f),
    '"cardinality(e) > cardinality(f)" assert failed';
 
    assert
      (e > f) ,
    'e > f assert failed';
  end;
 
  ------------------------------------------------------------------------------
  -- g's cardinality = h's.
  -- So pairwise comparison is feasible for all values, and is equal.
  -- g's ndims > h's.
  -- g's lb-1 < h's.
  -- Ndims has higher priority among ndims and lower bounds,
  -- so g is deemed to be GREATER THAN h.
  declare
    g constant int[] := '{{10, 20, 30}, {40, 50, 60}}';
    h constant int[] := '[2:7]={10, 20, 30, 40, 50, 60}';
  begin
    assert
      cardinality(g) = cardinality(h),
    '"cardinality(g) = cardinality(h)" assert failed';
 
    assert
      g[1][1] = h[2] and
      g[1][2] = h[3] and
      g[1][3] = h[4] and
      g[2][1] = h[5] and
      g[2][2] = h[6] and
      g[2][3] = h[7] ,
    '"g-to-h" eqality test assert failed';
 
    assert
      array_ndims(g) > array_ndims(h),
    '"ndims(g) > ndims(h)" assert failed';
 
    assert
      array_lower(g, 1) < array_lower(h, 1),
    '"lower(g, 1) < lower(h, 1)" assert failed';
 
    assert
      (g > h) ,
    '"g > h" assert failed';
  end;
 
  ------------------------------------------------------------------------------
  declare
    i constant int[] := '[5:6][4:6]={{10, 20, 30}, {40, 50, 60}}';
    j constant int[] := '[3:4][6:8]={{10, 20, 30}, {40, 50, 60}}';
  begin
    assert
      cardinality(i) = cardinality(j),
    '"cardinality(i) = cardinality(j)" assert failed';
 
    assert
      i[5][4] = j[3][6] and
      i[5][5] = j[3][7] and
      i[5][6] = j[3][8] and
      i[6][4] = j[4][6] and
      i[6][5] = j[4][7] and
      i[6][6] = j[4][8] ,
    '"i-to-j" eqality test assert failed';
 
    assert
      array_ndims(i) = array_ndims(j),
    '"ndims(i) = ndims(j)" assert failed';
 
    assert
      array_lower(i, 1) > array_lower(j, 1),
    '"lower(i, 1) > lower(j, 1)" assert failed';
 
    assert
      (i > j) ,
    '"i > j" assert failed';
  end;
 
  ------------------------------------------------------------------------------
end;
$body$;
```

示例2：

```
-- Any two arrays can be compared without error if they have the same data type.
-- Insensitive to the geometric properties.
do $body$
declare
  a constant int[] := '[2:3][4:5]={{10, 20}, {30, 40}}';
  b constant int[] := '[5:6]={20, 30}';
  c constant int[] := '[6:9]={40, 50, 70, 70}';
  d constant int[] := '[2:4]={50, 60, 70}';
begin
  assert
    -- Containment
    (b @> b) and
    (b <@ a) and
 
    -- Overlap.
    -- The definition of the semantics makes the LHS, RHS order immaterial.
    (a && c) and
    (c && a) and
 
    -- a and d have NO values in common.
    not (a && d),
  'unexpected';
end;
$body$;
```

## **切片运算符**

| 运算符                                 | 1-d only? | 描述                                                         |
| -------------------------------------- | --------- | ------------------------------------------------------------ |
| [[lb1:ub1]...[lbN:ubN]](#_slice运算符) |           | 返回一个新数组，其长度是通过沿每个维度指定切片的下界和上界来定义的。这些指定的切片边界不能超过源数组的边界。新数组具有与源数组相同的维度，并且在每个轴上其下界为1。 |

### slice运算符
目的：返回一个新数组，其长度是通过指定切片沿每个维度的下限和上限来定义的。 

语法：
输入值:       [lb_1:ub_1] ... [lb_N:ub_N]anyarray
返回值:      anyarray
注意：

* 必须为输入数组的N个维度中的每一个指定切片的下限和上限作为int值。
* 指定的切片边界不能超过源数组的边界。
* 新数组具有与源数组相同的维度，并且其下界在每个轴上为1。 

示例如下：

```
create table t(k int primary key, arr text[]);
 
insert into t(k, arr)
values (1, '
  [2:4][3:6][4:5]=
  {
    {
      {a,b}, {c,d}, {e,f}, {g,h}
    },
    {
      {i,j}, {k,l}, {m,n}, {o,p}
    },
    {
      {q,r}, {s,t}, {u,v}, {w,x}
    }
  }
  '::text[]);
 
select arr as "old value of arr" from t where k = 1;
 
select
  array_lower(arr, 1) as "lb-1",
  array_upper(arr, 1) as "ub-1",
  array_lower(arr, 2) as "lb-2",
  array_upper(arr, 2) as "ub-2",
  array_lower(arr, 3) as "lb-3",
  array_upper(arr, 3) as "ub-3"
from t where k = 1;
```

分别返回信息如下：

```
 lb-1 | ub-1 | lb-2 | ub-2 | lb-3 | ub-3
------+------+------+------+-----+------
   2 |   4 |   3 |   6 |   4 |   5
```

与

```
                     old value of arr
-------------------------------------------------------------------------------------------------
 [2:4][3:6][4:5]={{{a,b},{c,d},{e,f},{g,h}},{{i,j},{k,l},{m,n},{o,p}},{{q,r},{s,t},{u,v},{w,x}}}
```

现在进行如下切片：

```
update t
set arr = arr[2:3][4:5][3:4]
where k = 1;
 
select arr as "new value of arr" from t where k = 1;
 
select
  array_lower(arr, 1) as "lb-1",
  array_upper(arr, 1) as "ub-1",
  array_lower(arr, 2) as "lb-2",
  array_upper(arr, 2) as "ub-2",
  array_lower(arr, 3) as "lb-3",
  array_upper(arr, 3) as "ub-3"
from t where k = 1;
```

分别返回信息如下：

```
   new value of arr
-------------------------------
 {{{c},{e}},{{k},{m}}}
```

与：

```
 lb-1 | ub-1 | lb-2 | ub-2 | lb-3 | ub-3
------+------+------+------+-----+------
   1 |   2 |   1 |   2 |   1 |    1
```

可以看到，返回的下界都是1

## **连接函数和运算符**

这些函数要求两个数组具有相同的数据类型和兼容的维度。

| 函数和运算符                         | 1-d only? | 描述                             |
| ------------------------------------ | --------- | -------------------------------- |
| [array_cat()](#_array_cat())         |           | 返回两个兼容的任意数组值的串联。 |
| [array_append()](#_array_append())   |           | 向一个数组的末端追加一个元素值。 |
| [array_prepend()](#_array_prepend()) |           | 向一个数组的首部追加一个元素     |


### array_cat()
目的：返回两个兼容的任意数组值的串联。

语法：

输入值:              anyarray, anyarray
返回值:             anyarray

注意：DO块表明 || 运算符能够实现array_cat()函数的全部功能。

```
do $body$
declare
  arr_1 constant int[] := '{1, 2, 3}'::int[];
  arr_2 constant int[] := '{4, 5, 6}'::int[];
  val constant int := 5;
  workaround constant int[] := array[val];
begin
  assert
    array_cat(arr_1, arr_2)      = arr_1||arr_2 and
    array_cat(arr_1, workaround) = arr_1||val   ,
  'unexpected';
end;
$body$;
```

### array_append()
目的：向一个数组的末端追加一个元素值。

语法：
输入值:              anyarray, anyelement
返回值:             anyarray

注意：DO块表明 || 运算符能够实现array_append()函数的全部功能，值兼容。

```
do $body$
declare
  arr constant int[] := '{1, 2, 3, 4}'::int[];
  val constant int := 5;
  workaround constant int[] := array[val];
begin
  assert
    array_append(arr, val) = arr||val                   and
    array_append(arr, val) = array_cat(arr, workaround) ,
  'unexpected';
end;
$body$;
```


### array_prepend()
目的：向一个数组的首部追加一个元素

语法：
输入值:              anyelement, anyarray
返回值:             anyarray

注意：DO块表明 || 运算符能够实现array_prepend()函数的全部功能，值兼容。

```
do $body$
declare
  arr constant int[] := '{1, 2, 3, 4}'::int[];
  val constant int := 5;
  workaround constant int[] := array[val];
begin
  assert
    array_prepend(val, arr) = val||arr                   and
    array_prepend(val, arr) = array_cat(workaround, arr) ,
  'unexpected';
end;
$body$;
```

以下两个示例展示了一维数组，与多维数组的应用：

示例一（一维数组）：

```
create type rt as (f1 int, f2 text);
 
do $body$
declare
  arr constant rt[] := array[(3, 'c')::rt, (4, 'd')::rt, (5, 'e')::rt];
 
  prepend_row  constant rt := (0, 'z')::rt;
  prepend_arr  constant rt[] := array[(1, 'a')::rt, (2, 'b')::rt];
  append_row   constant rt := (6, 'f')::rt;
 
  cat_result   constant rt[] := prepend_row||prepend_arr||arr||append_row;
 
  expected_result constant rt[] :=
    array[(0, 'z')::rt, (1, 'a')::rt, (2, 'b')::rt, (3, 'c')::rt,
         (4, 'd')::rt, (5, 'e')::rt, (6, 'f')::rt];
 
begin
  assert
    (cat_result   = expected_result),
  'unexpected';
end;
$body$;
```

示例二（多维数组）：

```
do $body$
declare
  -- arr_1 and arr_2 are demensionally compatible.
  -- Its's OK for array_length(*, 1) to differ.
  -- But array_length(*, 1) must be the same.
  arr_1 constant int[] :=
    array[
       array[11, 12, 13],
       array[21, 22, 23]
    ];
 
  arr_2 constant int[] :=
    array[
       array[31, 32, 33],
       array[41, 42, 43],
       array[51, 52, 53]
    ];
 
  -- Notice that this is a 1-d array.
  -- Its lenth is the same as that of arr_1
  -- along arr_1's SECOND dimension.
  arr_3 constant int[] := array[31, 32, 33];
 
  -- Notice that bad_arr is dimensionally INCOMPATIBLE with arr_1:
  -- they have different lengths along their SECOND major dimension.
  bad_arr constant int[] :=
    array[
       array[61, 62, 63, 64],
       array[71, 72, 73, 74],
       array[81, 82, 83, 84]
    ];
 
  expected_cat_1 constant int[] :=
    array[
       array[11, 12, 13],
       array[21, 22, 23],
       array[31, 32, 33],
       array[41, 42, 43],
       array[51, 52, 53]
    ];
 
  expected_cat_2 constant int[] :=
    array[
       array[11, 12, 13],
       array[21, 22, 23],
       array[31, 32, 33]
    ];
begin
  assert
    arr_1||arr_2 = expected_cat_1 and
    arr_1||arr_3 = expected_cat_2,
  'unexpected';
 
  declare
    a int[];
  begin
    -- ERROR: cannot concatenate incompatible arrays.
    a := arr_1||bad_arr;
  exception
    when array_subscript_error then null;
  end;
end;
$body$;
```

## **更改函数和运算符**

| 函数和运算符                                               | 1-d only? | 描述                                       |
| ---------------------------------------------------------- | --------- | ------------------------------------------ |
| [array_replace()](#_array_replace())                       |           | 将每一个等于给定值的数组元素替换成一个新值 |
| [arr[idx_1]...[idx_N] := val](#_arr[idx_1]...[idx_N]:=val) |           | 更新数组值                                 |
| [array_remove()](#_array_remove())                         | 1-d       | 从数组中移除所有等于给定值的所有元素       |

### array_replace()
本小节中描述的每一种方法，使用array_replace()函数，与显式设置数组值，都可以用于更改数组中的值。但这两种方法有如下的不同点：

* array_replace()将所有与指定值匹配的值更改为相同的新值，而不考虑它们在数组中的地址。
* 设置数组值，则仅对当前值进行更改。 

目的：将每一个等于给定值的数组元素替换成一个新值

语法：

输入值:       anyarray, anyelement, anyelement
返回值:      anyarray

例如：

```
create type rt as (f1 int, f2 text);
create table t(k int primary key, arr rt[]);
insert into t(k, arr)
values (1, '{"(1,rabbit)","(2,hare)","(3,squirrel)","(4,horse)"}'::rt[]);
 
select arr as "old value of arr" from t where k = 1;
 
update t
set arr = array_replace(arr, '(3,squirrel)', '(3,bobcat)')
where k = 1;
 
select arr as "new value of arr" from t where k = 1;
```

返回如下信息：

```
                   old value of arr
------------------------------------------------------
 {"(1,rabbit)","(2,hare)","(3,squirrel)","(4,horse)"}
 
                  new value of arr
----------------------------------------------------
 {"(1,rabbit)","(2,hare)","(3,bobcat)","(4,horse)"}
```

如下是更多的，针对不同情况的演示示例：

示例一（一维数组的基本数据类型）：

```
do $body$
declare
  old_val constant int := 42;
  new_val constant int := 17;
 
  arr constant int[] :=
    array[1, old_val, 3, 4, 5, old_val, 6, 7];
 
  expected_modified_arr constant int[] :=
    array[1, new_val, 3, 4, 5, new_val, 6, 7];
begin
  assert
    array_replace(arr, old_val, new_val) = expected_modified_arr,
  'unexpected';
end;
$body$;
```

示例二（一维数组的row类型）：

```
create type rt as (f1 int, f2 text);
 
do $body$
declare
  old_val constant rt := (42, 'x');
  new_val constant rt := (17, 'y');
 
  arr constant rt[] :=
    array[(1, 'a')::rt, old_val, (1, 'a')::rt, (2, 'b')::rt, (3, 'c')::rt,
                        old_val, (4, 'd')::rt, (5, 'e')::rt];
 
  expected_modified_arr constant rt[] :=
    array[(1, 'a')::rt, new_val, (1, 'a')::rt, (2, 'b')::rt, (3, 'c')::rt,
                        new_val, (4, 'd')::rt, (5, 'e')::rt];
begin
  assert
    array_replace(arr, old_val, new_val) = expected_modified_arr,
  'unexpected';
end;
$body$;
```

示例三（二维数组的基本数据类型）：

```
do $body$
declare
  old_val constant int := 22;
  new_val constant int := 97;
 
  arr int[] :=
    array[
       array[11, 12],
       array[11, old_val],
       array[32, 33]
    ];
 
  expected_modified_arr constant int[] :=
    array[
       array[11, 12],
       array[11, new_val],
       array[32, 33]
    ];
begin
  arr := array_replace(arr, old_val, new_val);
 
  assert
    arr = expected_modified_arr,
  'unexpected';
end;
$body$;
```

### arr\[idx_1]...\[idx_N] := val
目的：更新数组值

语法：
input/output value: anyarray, "vector of index values"

例如：

```
create table t(k int primary key, arr int[]);
 
insert into t(k, arr) values (1,  '{1, 2, 3, 4}');
 
update t set arr[2] = 42 where k = 1;
 
select arr from t where k = 1;
```

返回信息如下：

```
    arr
------------
 {1,42,3,4}
```


如下是更多的，针对不同情况的演示示例：

示例一（基本数据类型）：

```
do $body$
declare
  old_val constant int := 42;
  new_val constant int := 17;
 
  arr int[] :=                            array[1, 2, old_val, 4];
  expected_modified_arr constant int[] := array[1, 2, new_val, 4];
  old_arr constant int[] := arr;
begin
  arr[3] := new_val;
  assert
    old_arr =               '{1, 2, 42, 4}' and
    expected_modified_arr = '{1, 2, 17, 4}' and
    arr = expected_modified_arr,
  'unexpected';
end;
$body$;
```

示例二（record类型）：

```
create type rt as (f1 int, f2 text);
 
do $body$
declare
  old_val constant rt := (42, 'x');
  new_val constant rt := (17, 'y');
 
  arr rt[] :=
    array[(1, 'a')::rt, old_val, (1, 'a')::rt, (2, 'b')::rt, (3, 'c')::rt,
                        old_val, (4, 'd')::rt, (5, 'e')::rt];
 
  expected_modified_arr constant rt[] :=
    array[(1, 'a')::rt, new_val, (1, 'a')::rt, (2, 'b')::rt, (3, 'c')::rt,
                        new_val, (4, 'd')::rt, (5, 'e')::rt];
 
  old_arr constant rt[] := arr;
begin
  arr[2] := new_val;
  arr[6] := new_val;
 
  assert
    old_arr =
      '{"(1,a)","(42,x)","(1,a)","(2,b)","(3,c)","(42,x)","(4,d)","(5,e)"}' and
    expected_modified_arr =
      '{"(1,a)","(17,y)","(1,a)","(2,b)","(3,c)","(17,y)","(4,d)","(5,e)"}' and
    arr = expected_modified_arr,
  'unexpected';
end;
$body$;
```

示例三（二维数组的基本数据类型）：

```
do $body$
declare
  old_val constant int[] := array[21, 22, 23, 24];
  new_val constant int[] := array[81, 82, 83, 84];
 
  arr int[] :=
    array[
       array[11, 12, 13, 14],
       old_val,
       array[31, 32, 33, 34]
    ];
 
  expected_modified_arr constant int[] :=
    array[
       array[11, 12, 13, 14],
       new_val,
       array[31, 32, 33, 34]
    ];
 
  len_1 constant int := array_length(arr, 1);
  len_2 constant int := array_length(arr, 2);
begin
  assert
    (len_1 = 3) and (len_2 = 4),
  'unexpected';
 
  -- OK to extract a slice. But, even though it's tempting to picture this as one row,
  -- it is nevertheless a 2-d array with "array_length(arr, 1)" equal to 1.
  assert
    arr[2:2][1:4] = array[old_val],
  'unexpected';
 
  -- You cannot use the slice notation to specify the target of an assignment.
  -- So this
  --   arr[2:2][1:4] = array[new_val];
  -- causes a compilation error.
 
  -- Similarly, this is meaningless. (But it doesn't cause a compilation error.)
  -- Because it's a 2-d array, its values (individual values or slices) must be
  -- addressed using two indexes or two slice ranges.
  assert
    arr[2] is null,
  'unexpected';
 
  -- Change the individual, addressable, values one by one.
  for j in array_lower(arr, 2)..array_upper(arr, 2) loop
    arr[2][j] := new_val[j];
  end loop;
 
  assert
    arr = expected_modified_arr,
  'unexpected';
end;
$body$;
```

### array_remove()
目的：从数组中移除所有等于给定值的所有元素

语法：

输入值:       anyarray, anyelement
返回值:      anyarray

注意：此函数要求要从中删除值的数组是一维的数组。

例如：

```
create table t(k int primary key, arr int[]);
insert into t(k, arr)
values (1, '{1, 2, 2, 2, 5, 6}'::int[]);
 
select arr as "old value of arr" from t where k = 1;
 
update t
set arr = array_remove(arr, 2)
where k = 1;
 
select arr as "new value of arr" from t where k = 1;
```

分别返回如下信息：

```
 old value of arr
------------------
 {1,2,2,2,5,6}
 
 new value of arr
------------------
 {1,5,6}
```

## **转换函数**

| 函数                                     | 1-d only? | 描述                                                         |
| ---------------------------------------- | --------- | ------------------------------------------------------------ |
| [array_to_string()](#_array_to_string()) |           | 返回一个文本值，该值是通过每个数组值来计算的，通过::text类型转换，按行主顺序遍历这些值，并在每个数组值之间使用提供的分隔符。 |

### array_to_string()
目的：返回一个文本值，该值是通过每个数组值来计算的，通过::text类型转换，按行主顺序遍历这些值，并在每个数组值之间使用提供的分隔符。

语法：
输入值:       anyarray, text [, text]
返回值:      text

```
create type rt as (f1 int, f2 text);
create table t(k int primary key, arr rt[]);
insert into t(k, arr) values(1,
  array[
    array[
      array[(1, 'a')::rt, (2, null)::rt, null, (3, 'c')::rt]
    ]
  ]::rt[]
);
 
select arr::text from t where k = 1;
```

返回如下信息：

```
                arr
-----------------------------------
 {{{"(1,a)","(2,)",NULL,"(3,c)"}}}
```

接下来，执行如下脚本：

```
select
  array_to_string(
    arr,     -- the input array
    ' | ')   -- the delimiter
from t
where k = 1;
```

返回信息如下：

```
   array_to_string
----------------------
 (1,a) | (2,) | (3,c)
```

注意：第三个NULL数组值并没有显示。这意味着逗号和右括号分隔符之间没有任何字符。 

继续执行如下脚本：

```
select
  array_to_string(
    arr,     -- the input array
    ' | ',   -- the delimiter
    '?')     -- the null indicator
from t
where k = 1;
```

返回信息如下：

```
     array_to_string
--------------------------
 (1,a) | (2,) | ? | (3,c)
```

第三个数组值现在用 ? 显示，但是，事实上，第二个数组值中的“f2”为NULL这一点并不没有用 ? 显示。换句话说，这种可视化NULL的技术仅在顶级数组值的粒度上应用，而当这些值是复合值时，并不会在这些值内应用。 

## **表函数**

| 函数                                             | 1-d only? | 描述                                                         |
| ------------------------------------------------ | --------- | ------------------------------------------------------------ |
| [unnest()](#_unnest())                           |           | 将一个数组扩展成一组行在SELECT语句的FROM子句中使用。简单重载接受单个任意数组值，并返回一个集合。重载接受任意数组值的可变列表，并返回具有多个列的集合，其中每个列依次具有相应的简单重载的输出。 |
| [generate_subscripts()](#_generate_subscripts()) |           | 在SELECT语句的FROM子句中使用。返回沿指定数组的指定维度的索引值。 |

### unnest()
此函数有两个重载函数。

#### *unnest() 重载函数一*
目的：将单个数组中的值转换为SQL表。

语法：

输入值:       anyarray
返回值:      SETOF anyelement

unnest的输入是一个数组，在SQL语句中，设置bsqlsh变量“result_arr”，参见array_agg()的代码示例，必须引起来它，并将其类型转换为“rt[]”。这可以通过\set 元命令来完成，如下所示：

```
\set unnest_arg '\'':result_arr'\'::rt[]'
\echo :unnest_arg
```

\echo 元命令显示以下内容：

```
'{"(1,dog)","(2,cat)","(3,ant)"}'::rt[]
```

完整示例如下：

```
create type rt as (f1 int, f2 text);
 
with tab as (
  values
    (1::int, 'dog'::text),
    (2::int, 'cat'::text),
    (3::int, 'ant'::text))
select array_agg((column1, column2)::rt order by column1) as arr
from tab;
 
\gset result_
\echo :result_arr
 
\set unnest_arg '\'':result_arr'\'::rt[]'
\echo :unnest_arg
 
with
  rows as (
    select unnest(:unnest_arg) as rec)
select
  (rec).f1,
  (rec).f2
from rows
order by 1;
```

返回信息如下：

```
 f1 |  f2
---+-----
 1 | dog
 2 | cat
 3 | ant
```

#### *unnest() 重载函数二*
目的：将数组的可变列表中的值转换为SQL表，该表的每一列都是相应输入数组值的集合。此重载只能在子查询的FROM子句中使用。每个输入数组可能具有不同的类型和不同的基数。基数最大的输入数组决定了输出行的数量。那些基数较小的输入数组的行在末尾用NULL填充。可选的WITH ORDINALITY 子句添加了一个对行进行编号的列。 

语法：

输入值:       <variadic list of> anyarray
返回值:      many coordinated columns of SETOF anyelement

示例如下：

```
create type rt as (a int, b text);
 
\pset null '<is null>'
select *
from unnest(
  array[1, 2],
  array[10, 20, 30, 45, 50],
  array['a', 'b', 'c', 'd'],
  array[(1, 'p')::rt, (2, 'q')::rt, (3, 'r')::rt, (4, 's')::rt]
)
with ordinality
as result(arr1, arr2, arr3, arr4_a, arr4_n, n);
```

返回如下信息：

```
   arr1  | arr2  |   arr3    |  arr4_a   |  arr4_n   |  n
-------------+-------+--------------+--------------+--------------+-----
       1 |  10 | a          |         1 | p         | 1
       2 |  20 | b          |         2 | q         | 2
 <is null> |  30 | c          |         3 | r         | 3
 <is null> |  45 | d          |         4 | s         | 4
 <is null> |  50 | <is null>    | <is null>   | <is null>  | 5
```


### generate_subscripts()
目的：在SELECT语句的FROM子句中使用。返回沿指定数组的指定维度的索引值。

语法：

输入值:       anyarray, integer, boolean
返回值:      SETOF integer

第二个输入参数指定应该沿其生成索引值的维度。第三个可选的输入参数控制值的顺序。默认值FALSE表示从索引下界到索引上界按升序生成索引值；值TRUE意味着按照从索引上界到索引下界的降序生成索引值。

例如：

```
drop function if exists arr() cascade;
create function arr()
  returns int[]
  language sql
as $body$
  select array[17, 42, 53, 67]::int[];
$body$;
 
select generate_subscripts(arr(), 1) as subscripts;
```

返回信息如下：

```
 subscripts 
------------
        1
        2
        3
        4
select generate_subscripts(arr(), 1, true) as subscripts;
```

则返回信息如下：

```
 subscripts 
------------
        4
        3
        2
        1
```