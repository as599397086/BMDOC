sqlsh发出的提示符可以根据用户的喜好自定义。PROMPT1、PROMPT2和PROMPT3这三个变量包含了描述提示符外观的字符串和特殊转义序列。
Prompt 1 是当sqlsh等待新命令时发出的常规提示符。
Prompt 2 是在命令输入时需要更多输入时发出的提示符，例如因为当命令没有被分号终止或者引用没有被关闭时就会发出这个提示符。
Prompt 3是在运行一个SQL COPY FROM STDIN命令并且需要在终端上输入一个行值时，会发出Prompt 3。

sqlsh会打印被选中的提示符变量，除非碰到一个百分号（%），在这种情况下，它会替换“[预定义替换](#_预定义替换)”中定义的其他文本。

要在提示中插入百分号，请写%%。 

对于Prompt 1和Prompt 2，默认的提示符是 '%/%R%# ' ，对于prompt 3 是'>> ' 。

## **预定义替换**

### %M

数据库服务器的完整主机名（带有域名），或者当该连接是建立在一个 Unix 域套接字上时则是[local]，或者当 Unix 域套接字不在编译在系统内的默认位置上时则是[local:/dir/name]。

### %m

数据库服务器的主机名称（在第一个点处截断），或者当连接建立在一个 Unix 域套接字上时是[local]。

### %>

数据库服务器正在监听的端口号。

### %n

数据库会话的用户名（在数据库会话期间，这个值可能会因为命令SET SESSION AUTHORIZATION的结果而改变）。

### %/

当前数据库的名称。

### %~

和 %/ 类似，但是如果数据库是默认数据库时输出是~（波浪线）。

### %#

如果会话用户时一个数据库超级用户，则是#，否则是一个>（在数据库会话期间，这个值可能会因为命令SET SESSION AUTHORIZATION的结果而改变）。

### %p

当前连接到的后端的进程 ID。

### %R

在prompt 1下通常是 = ，但如果会话位于一个条件块的一个非活动分支中则是@，如果会话处于单行模式中则是^，如果会话从数据库断开连接（\connect失败时会发生这种情况）则是!。
在prompt 2 中，根据sqlsh期待更多的输入，%R会被一个相应的字符替换：

1) 如果命令还没有被终止是-，如果有一个未完的/* ... */注释则是*
2) 如果有一个未完的被引用字符串则是一个单引号 ‘
3) 如果有一个未完的被引用标识符则是一个双引号 “
4) 如果有一个未完的美元引用字符串则是一个美元符号 $
5) 如果有一个还没有被配对的左圆括号则是(

在prompt 3 中%R不会产生任何东西。

### %x

事务状态：当不在事务块中时是一个空字符串，在一个事务块中时是*，在一个失败的事务块中时是!，当事务状态是未判定时（例如因为没有连接）为?。

### %l

当前语句中的行号，从1开始。

### %digits

带有指定的八进制码的字符会被替换。

### %:name:

sqlsh变量name的值。详见[变量](#_变量)。

### %`command`

command的输出，类似于平常的“反引号”替换。

### %[ ... %]

提示符可以包含终端控制字符，例如改变提示符文本的颜色、背景或者风格以及更改终端窗口标题的控制字符。为了让Readline的行编辑特性正确工作，这些不可打印的控制字符必须被包裹在%[和%]之间以指定它们是不可见的。在提示附中可以出现多个这样的标识对。例如：

testdb=> \set PROMPT1 '%[%033[1;33;40m%]%n@%/%R%[%033[0m%]%# '
会导致一个在兼容 VT100 的彩色终端上的粗体（1;）的、黑底黄字（33;40）的提示符。

## **命令行编辑**

为了方便的行编辑和检索，sqlsh支持Readline库。sqlsh退出时命令历史会被自动保存，而当sqlsh启动时命令历史会被重新载入。sqlsh也支持 tab 补全，不过补全逻辑绝不是一个SQL解析器。tab 补全产生的查询也可能会受其他 SQL 命令干扰，例如SET TRANSACTION ISOLATION LEVEL。如果出于某种原因不想用 tab 键补全，可以把下面的代码放在主目录下的名为.inputrc文件中关闭该特性：

```
$if psql
set disable-completion on
$endif
```

（这不是sqlsh特性而是Readline的特性。进一步的细节请阅读它的文档。）