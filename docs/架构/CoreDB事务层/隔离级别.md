事务隔离是处理数据库中并发事务的基础。 SQL-92 标准定义了四个事务隔离级别（按严格程度降序排列）：可串行化、可重复读取、已提交读和未提交读。

AiSQL 支持以下三种最严格的事务隔离级别：

* 已提交读，它映射到同名的 SQL 隔离级别。 此隔离级别保证每个语句都可以看到在发出之前已提交的所有数据（这也隐式意味着该语句可以看到一致的快照）。 此外，此隔离级别在内部处理读取重新启动和冲突错误。 换句话说，客户端不会看到读取重新启动和冲突错误（除非有例外）。
* 可串行化，映射到同名的 SQL 隔离级别。 此隔离级别保证事务以相当于串行（顺序）调度的方式运行。
* 快照，映射到 SQL 可重复读隔离级别。 此隔离级别保证事务中进行的所有读取都看到数据库的一致快照，并且仅当事务本身所做的更新与该快照之后提交的事务所做的任何并发更新没有冲突时，事务本身才能成功提交。

BSQL 和 BCQL API 之间的事务隔离级别支持有所不同：

* BSQL 支持可串行化、快照和读已提交隔离级别。
* BCQL 仅支持使用 BEGIN TRANSACTION 语法的快照隔离。

与 PostgreSQL 类似，您可以为 BSQL 指定“未提交读”，但其行为与“已提交读”相同。

已提交读承诺支持当前处于技术预览版中。 仅当 DBServer 标志 bm_enable_read_comfilled_isolation 设置为 true 时才支持此级别。 默认情况下，此标志为 false，在这种情况下，AiSQL 事务层的读已提交隔离级别将回退到更严格的快照隔离。 BSQL API 的默认隔离级别本质上是快照，因为已提交读（BSQL API 和 PostgreSQL 语法默认值）映射到快照隔离。

**1.CoreDB中的内部锁定**
为了支持三种隔离级别，锁管理器内部支持以下三种类型的锁：

* 可串行读锁由可串行事务对其读取的值进行锁定，以保证在事务提交之前这些值不会被修改。

* 可串行化事务在其写入的值上获取可串行化写锁。
* 快照隔离写锁由快照隔离（以及已提交的读）事务对其修改的值进行获取。

下面的矩阵显示了这些类型的锁之间的高层冲突：

|            | 快照隔离写 | 可串行写 | 可串行读 |
| ---------- | ---------- | -------- | -------- |
| 快照隔离写 | ×冲突      | ×冲突    | ×冲突    |
| 可串行写   | ×冲突      | √不冲突  | ×冲突    |
| 可串行读   | ×冲突      | ×冲突    | √不冲突  |

也就是说，可串行读取会锁定写入者，但允许其他并发读取者。 可串行化写入锁会按预期阻止读取器，但不会阻止其他可串行化写入器。 最后，快照隔离写入锁会阻塞所有其他读取器和写入器。

由于可串行化写锁不会阻塞其他可串行化写入者，因此在可串行化隔离级别允许并发盲写。 盲写是对该事务先前未读取过的位置的写入。 假设没有其他冲突，两个可串行化的事务盲目地写入同一位置可以并行进行； 之后该位置的值将是最后提交的事务写入的值。

尽管为了简单起见这里将其描述为单独的锁类型，但快照隔离写锁类型实际上在内部实现为其他两种锁类型的组合。 也就是说，获取单个快照隔离写锁相当于同时获取可序列化读锁和可序列化写锁。

**2.锁定粒度**
可以在多个粒度级别上进行锁定。 例如，可以在整个表、单行或单行的单列级别获取可串行化的读锁。 这样的锁将阻止以该粒度或更细粒度获取写锁的尝试。 因此，例如，在行级别获取的读锁将阻止写入整行或该行中的任何列的尝试。

除了上述粒度级别之外，CoreDB 中还可以在主键列的前缀处进行锁定，将哈希列视为单个单元。 例如，如果您通过以下方式创建了 BSQL 表：

```
CREATE TABLE test (h1 INT, h2 INT, r1 INT, r2 INT, v INT w INT PRIMARY KEY ((h1,h2) HASH, r1 ASC, r2 ASC));
```

那么以下任何对象都可以被锁定：

* 整个Tile
* h1=2、h2=3 的所有行
* 所有具有 h1=2、h2=3、r1=4 的行
* h1=2、h2=3、r1=4、r2=5 的行
* h1=2、h2=3、r1=4、r2=5 的行的第 v 列

对于BCQL，粒度存在于列级别以下； 例如，只能锁定map数据类型的一列的一个键。

**3.高效检测不同粒度锁之间的冲突**
处理不同粒度的锁的直接方法是拥有从可锁定对象到锁类型的映射。 然而，这对于检测冲突来说效率太低：例如，尝试在Tile级别添加锁将需要检查该Tile中的每一行和每一列的锁。

为了提高冲突检测效率，AiSQL 为每个可锁定对象存储有关其子对象上的任何锁定的额外信息。 特别是，它不仅对 X 进行锁定，还对 X 进行普通锁定，并对包含 X 的所有对象进行该锁定的较弱版本。普通锁定称为强锁定，较弱的变体称为弱锁定。

例如，假设 AiSQL 仅具有Tile级和行级粒度。 要在行级别（例如在Tile b 的r 行上）获取可串行化写锁，需要在行级别（在r 上）获取强写锁，并在Tile 级别（在b 上）获取弱写锁。 为了在Tile级别获取可串行化的读锁（也假设在b上），AiSQL只需在Tile级别获取强读锁（在b上）。

使用以下冲突规则，AiSQL 可以仅根据两个原始锁在任何可锁定对象上的强/弱锁是否会发生冲突来决定它们是否会发生冲突：

* 两个强锁发生冲突当且仅当它们冲突时忽略它们的强度
  例如，前面矩阵中的可串行化写入与可串行化读取冲突
* 两个弱锁永远不会冲突
* 强锁与弱锁冲突当且仅当它们冲突且忽略它们的强度

也就是说，对于每个有两个锁的可锁定对象，它们在上述规则下会发生冲突吗？ 不需要枚举任何对象的子对象。

考虑我们的示例，其中具有行级别的可串行化写锁和Tile级别的可串行化读锁。 在Tile级别检测到冲突是因为b上的强读弱写锁冲突，因为普通的读锁和写锁冲突。

如果涉及到同一个Tile中不同行的两个行级快照隔离写锁怎么办？ 未检测到冲突，因为Tile级锁较弱，而强行级锁位于不同的行上。 如果它们涉及同一行，则将检测到冲突，因为两个强快照隔离写锁发生冲突。

包括强/弱的区别，完整的冲突矩阵变为：

|              | 强快照隔离写 | 弱快照隔离写 | 强可串行化写 | 弱可串行化写 | 强可串行化读 | 弱可串行化读 |
| ------------ | ------------ | ------------ | ------------ | ------------ | ------------ | ------------ |
| 强快照隔离写 | ×冲突        | ×冲突        | ×冲突        | ×冲突        | ×冲突        | ×冲突        |
| 弱快照隔离写 | ×冲突        | √不冲突      | ×冲突        | √不冲突      | ×冲突        | √不冲突      |
| 强可串行化写 | ×冲突        | ×冲突        | √不冲突      | √不冲突      | ×冲突        | ×冲突        |
| 弱可串行化写 | ×冲突        | √不冲突      | √不冲突      | √不冲突      | ×冲突        | √不冲突      |
| 强可串行化读 | ×冲突        | ×冲突        | ×冲突        | ×冲突        | √不冲突      | √不冲突      |
| 弱可串行化读 | ×冲突        | √不冲突      | ×冲突        | √不冲突      | √不冲突      | √不冲突      |

 