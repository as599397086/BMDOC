事务和强一致性是任何 RDBMS 的基本要求。 CoreDB 专为强一致性而设计。 它支持任何规模的跨行、多个Tile和多个节点的完全分布式原子性、一致性、隔离性、持久性 (ACID) 事务。 事务可以跨 CoreDB 中的表。

事务是作为单个逻辑工作单元执行的一系列操作。 由于在事务内应用操作而导致的数据库中间状态对其他并发事务不可见，并且如果发生阻止事务完成的故障，则所有步骤都不会影响数据库。

请注意，CoreDB 内的所有更新操作都被视为事务，包括仅更新一行的操作，以及更新驻留在不同节点上的多行的操作。 如果启用自动提交模式，则每条语句都作为一个事务执行。

**1.时间同步**
AiSQL 集群中的事务可能需要更新跨集群中节点的多行。 为了符合 ACID，该事务所做的各种更新应该在固定时间立即可见，而不管集群中的哪个节点读取更新。 为了实现这一点，集群的节点必须就全局时间概念达成一致，这要求所有节点都能够访问高可用且全局同步的时钟。 Google Cloud Spanner 使用的 TrueTime 就是此类具有严格误差范围的时钟的一个示例。 然而，这种类型的时钟在许多部署中并不可用。 物理时钟（或挂钟）无法在节点之间完美同步，也无法对事件进行排序以建立节点之间的因果关系。

**混合逻辑时钟**
AiSQL 使用混合逻辑时钟 (HLC)，通过将使用 NTP 粗略同步的物理时钟与跟踪因果关系的 Lamport 时钟相结合来解决该问题。

AiSQL 集群中的每个节点首先计算其表示为元组（物理时间组件、逻辑组件）的 HLC。 任何节点上生成的 HLC 都是严格单调的，并且作为元组进行比较。 比较两个 HLC 时，物理时间部分优先于逻辑部分。

* 物理时间组件：AiSQL 使用节点的物理时钟（Linux 中的 CLOCK_REALTIME）来初始化其 HLC 的物理时间组件。 一旦初始化，物理时间分量只能更新为更高的值。
* 逻辑分量：对于给定的物理时间分量，HLC 的逻辑分量是单调递增的数字，提供在同一物理时间中发生的事件的排序。 它最初设置为 0。如果物理时间组件在任何点更新，逻辑组件将重置为 0。

在两个节点之间的任何 RPC 通信中，都会交换 HLC 值。 HLC 较低的节点将其 HLC 更新为较高的值。 如果节点上的物理时间超过其 HLC 的物理时间分量，则后者将更新为物理时间，并将逻辑分量设置为 0。因此，节点上的 HLC 单调递增。

相同的 HLC 用于确定读取点，以确定哪些更新应对最终客户端可见。 如果更新已安全地复制到大多数节点上，根据 Raft 协议，客户端可以确认该更新操作成功，并且可以安全地为该 HLC 之前的所有读取提供服务。 这构成了 AiSQL 中无锁多版本并发控制的基础。

**2.多版本并发控制**
AiSQL内部使用多版本并发控制（MVCC）来维护数据一致性，无需锁定行。 每个事务都处理数据库中截至某个混合时间戳的数据版本。 这可以防止事务读取并发运行的事务所做的中间更新，其中一些事务可能正在更新相同的行。 然而，每个事务都可以看到自己的更新，从而为每个数据库会话提供事务隔离。 使用 MVCC 可以最大限度地减少执行多个并发事务期间的锁争用。

**使用混合时间的MVCC**
AiSQL 实现 MVCC 并在内部跟踪与同一键对应的值的多个版本（例如，特定行中的特定列），如 RocksDB 之上的持久性中所述。 每个键的最后部分是一个时间戳，它可以快速导航到 RocksDB 键值存储中特定版本的键。

MVCC使用的时间戳来自混合时间算法，这是一种分布式时间戳分配算法，结合了本地实时（物理）时钟和Lamport时钟的优点。 混合时间算法确保由“A 在同一服务器上 B 之前发生”或“A 在一台服务器上发生，然后将 RPC 发送到 B 发生的另一台服务器”形式的因果链连接的事件始终被分配，且按升序排列的混合时间戳。 这是通过使用大多数 RPC 请求传播混合时间戳，并始终将接收服务器上的混合时间更新为观察到的最高值（包括服务器上的当前物理时间）来实现的。 AiSQL 事务模型的多个方面都依赖于混合时间的这些属性。 考虑以下示例：

* 即使有领导者更改，分配给同一Tile中已提交 Raft 日志条目的混合时间戳始终不断增加。 这是因为新领导者始终拥有先前领导者的所有已提交条目，并且它确保在附加新条目之前使用最后提交条目的时间戳更新其混合时钟。 此属性简化了选择安全混合时间来选择单片读取请求的逻辑。
* 尝试在特定混合时间从 Tile 读取数据的请求需要确保时间戳值低于读取时间戳的 Tile 中不会发生任何更改，这可能会导致结果集不一致。 在跨多个Tile的事务读取期间，需要在特定时间戳处从Tile读取数据。 由于读取时间戳被选为处理读取请求的 DBServer 上的当前混合时间，因此该条件变得更容易满足，因此正在读取的数据片的领导者上的混合时间立即更新为以下值： 至少与读取时间戳一样高。 那么读请求只需要等待 Raft 队列中时间戳值低于读时间戳的相关条目被复制并应用到 RocksDB 中，然后就可以继续处理读请求了。

**支持的隔离级别**

* AiSQL 支持以下事务隔离级别：
* 已提交读，映射到同名的 SQL 隔离级别。
* 可串行化，映射到同名的 SQL 隔离级别。
* 快照，映射到 SQL 隔离级别 REPEATABLE READ。

有关更多信息，请参阅 AiSQL 中的隔离级别。

**显式锁定**
与 PostgreSQL 一样，AiSQL 提供了各种行级锁模式来控制对表中数据的并发访问。 在 MVCC 未提供所需行为的情况下，这些模式可用于应用程序控制的锁定。 有关更多信息，请参阅 AiSQL 中的显式锁定。

**3.交易执行路径**
最终用户语句无缝映射到 AiSQL 内的一种事务类型。

**（1）单行事务**
AiSQL 的事务管理器自动检测更新单行的事务（而不是跨Tile或节点更新行的事务）。 为了实现高性能，对单行的更新直接更新该行，而无需使用单行事务路径（也称为快速路径）与事务状态表进行交互。 有关详细信息，请参阅单行事务 I/O 路径。

由于单行事务不必更新事务状态表，因此其性能远高于分布式事务。

INSERT、UPDATE 和 DELETE 单行 SQL 语句映射到单行事务。。

**INSERT语句**
所有单行 INSERT 语句：

```
INSERT INTO table (columns) VALUES (values);
```

**UPDATE语句**
指定所有主键的单行 UPDATE 语句：

```
UPDATE table SET column = <new_value> WHERE <all_primary_key_values_are_specified>;
```

使用 UPDATE .. ON CONFLICT 的单行 upsert 语句：

```
INSERT INTO table (columns) VALUES (values)
    ON CONFLICT DO UPDATE
    SET <values>;
```

如果对现有行执行更新，则它们应与 INSERT 子句中指定的值集匹配。

**DELETE语句**
指定所有主键的单行 DELETE 语句：

```
DELETE FROM table WHERE <all_primary_key_values_are_specified>;
```

（2）分布式事务
影响分布在多个Tile（在最一般情况下将托管在不同节点上）的一组行的事务使用分布式事务路径来执行事务。 在 AiSQL 中实现分布式事务需要使用事务管理器，它可以协调事务中包含的各种操作，并最终根据需要提交或中止事务。 有关详细信息，请参阅分布式事务 I/O 路径。

 