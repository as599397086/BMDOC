AiSQL 支持基于原子性、一致性、隔离性、持久性 (ACID) 原则的分布式事务，可修改多个分片中的多行。 这可以在 BCQL 和 BSQL 上下文中实现强一致的二级索引以及多表和多行 ACID 操作。

熟悉了上述概念后，请参阅事务I/O路径来大致了解分布式事务的生命周期。

## **临时记录Provisional records**

正如 AiSQL 将单分片 ACID 事务写入的值存储到 CoreDB 中一样，它需要将分布式事务写入的未提交的值存储在类似的持久数据结构中。 如果按照之前的常规值写入 CoreDB，会造成客户端通过不同的Tile服务器，在不同的时间点看到本不应该看到的、部分事务完成的数据，从而破坏原子性。 因此，AiSQL 将临时记录写入这样的Tile：这个Tile存放当前事务尝试修改的key（也即Tile Leader）。 这些事务被称为临时记录，而不是常规（永久）记录，因为在事务提交之前它们对读者来说是不可见的。

临时记录存储在同一 Tablet Peer 中的单独 RocksDB 实例中。 与其他可能的设计选项（例如将临时记录与常规记录内联存储，或者将它们与常规记录一起放在同一个 RocksDB 实例中）相比，所选择的方法具有以下优点：

* 扫描所有临时记录非常简单，这有助于清理中止或放弃的事务。
* 在读取路径期间，需要以与常规记录非常不同的方式处理临时记录，并将它们放在 RocksDB 键空间的单独部分中可以简化读取路径。
* 将临时记录存储在单独的 RocksDB 实例中允许每个实例具有不同的存储、压缩和刷新策略。

**临时记录的编码详细信息**
临时记录对应的 RocksDB 键值对共有三种类型，省略了将这些记录放在 RocksDB 中所有常规记录之前的一字节前缀，如下图所示：

![](../../assets/chapter9/16.png)


**1.主要临时记录Primary provisional records**

```
DocumentKey, SubKey1, ..., SubKeyN, LockType, ProvisionalRecordHybridTime -> TxnId, Value
```

DocumentKey、SubKey1、...、SubKey 组件与 CoreDB 对特定子文档（例如，行、列或集合类型列中的元素）的路径编码中的组件与 RocksDB 键完全匹配。

这些主要临时记录中的每一个也充当持久性可撤销锁。 与每个Tile的锁管理器维护的阻塞内存锁相比，存在一些相似之处和差异。 这些持久锁可以是与内存中仅领导者锁相同的任何类型（SI 写入、可串行化写入和读取，以及用于处理嵌套文档更改的单独的强和弱分类）。 然而，与领导者端内存锁不同，临时记录代表的锁可以被另一个冲突事务撤销。 冲突解决子系统确保对于任何两个冲突事务，至少其中一个被中止。

例如，假设快照隔离事务将行 row1 中的列 col1 设置为 value1。 那么DocumentKey就是row1，SubKey1就是col1。 假设临时记录以混合时间戳1516847525206000写入tablet，事务ID为7c98406e-2373-499d-88c2-25d72a4a178c。 RocksDB 中会有以下临时记录值：

```
row1, WeakSIWrite, 1516847525206000 -> 7c98406e-2373-499d-88c2-25d72a4a178c
row1, col1, StrongSIWrite, 1516847525206000 -> 7c98406e-2373-499d-88c2-25d72a4a178c, value1
```

WeakSIWrite 锁类型用于行（正在写入的列的父级），而 StrongSIWrite 锁类型用于列本身。 该列的临时记录也是存储事务写入的列值的位置。

**2.事务元数据记录**

```
TxnId -> StatusTabletId, IsolationLevel, Priority
```

* StatusTabletId：是跟踪此事务状态的Tile的 ID。 与保存用户数据的表和Tile的情况不同（从键到Tile使用基于哈希的映射），没有确定的方法通过事务 ID 计算事务状态Tile  ID，因此必须将此信息显式传递给所有处理特定事务的组件。
* 隔离级别：快照隔离或可串行化隔离。
* 优先级：当使用 Fail-on-Conflict 并发控制策略时，此优先级是在事务创建期间随机分配的。

**3.按事务 ID 索引的临时记录键**

```
TxnId, HybridTime -> primary provisional record key
```

此映射可以查找属于特定事务的所有临时 RocksDB 记录。 这在清理已提交或中止的事务时使用。 请注意，由于可以为具有相同混合时间戳的同一事务写入属于主临时记录的多个 RocksDB 键值对，因此在混合时间的编码表示的末尾使用递增计数器（称为写入 ID），以便 获取此反向索引的唯一 RocksDB 键。 此写入 ID 在临时记录的编码详细信息中的图中所示的 T130.0、T130.1 中显示为 .0、.1 等。

## **交易状态追踪Transaction status tracking**

原子性意味着事务写入的所有值要么都是可见的，要么都是不可见的。 AiSQL 已经通过 Raft 复制单分片更新并将其作为一批写入应用到底层 CoreDB 存储引擎，从而提供了单分片更新的原子性。 可以重复使用相同的方法来使事务状态更改原子化。 事务的状态在所谓的事务状态表中进行跟踪。 该表实际上只是系统中的另一个分片表，尽管它不使用 RocksDB，而是将所有数据存储在内存中，并由 Raft WAL 支持。 事务ID（全局唯一ID）作为表中的键，更新事务状态是基本的单分片ACID操作。 通过将表中该事务的状态记录的状态设置为已提交，作为该事务的一部分写入的所有值都将变得原子可见。

交易状态记录包含特定交易 ID 的以下字段：

**状态**：待处理、已提交或中止。 所有事务一开始都处于待处理状态，然后进展到已提交或中止状态，在这种状态下它们将永久保留，直到被清理。

提交事务后，将设置以下两个字段：
**提交混合时间戳**。 在将事务提交条目附加到其 Raft 日志时，选择该时间戳作为事务状态表的当前混合时间。 然后，它用作常规记录的最终 MVCC 时间戳，在应用和清理临时记录时替换事务的临时记录。
**参与的Tile的 ID 列表**。 事务提交后，事务写入的最终一组Tile就已知。 管理事务的tablet 服务器将此列表作为提交消息的一部分发送到事务状态tablet，并且事务状态tablet 确保向所有参与的tablet 通知事务的已提交状态。 此过程可能需要多次重试，并且只有重试完成后才能清除事务记录。

## **故障的影响**

临时记录被写入负责在事务中修改key的所有Tile副本。 当拥有已接收或即将接收临时记录的tablet的节点发生故障时，将在几秒（~2s）内为该tablet选举一个新的leader，如Leader Failure中所述。 查询层等待领导者选举发生，然后事务与新当选的领导者进一步进行。 在这种情况下，完成事务所需的时间会随着领导者选举所需的时间而增加。

事务管理器（通常是客户端连接的节点）将心跳发送到维护事务信息的事务状态Tile。 当管理器发生故障时，这些心跳会停止，临时记录会在一定时间后过期。 此时，状态Tile会自动取消该事务，因此相关的临时记录将不再阻止等待相同键的冲突事务。 连接到失败管理器的客户端会收到类似于以下内容的错误消息：

```
FATAL:  57P01: terminating connection due to unexpected postmaster exit
FATAL:  XX000: Network error: recvmsg error: Connection refused
```

由于客户端不知道事务 ID，因为客户端到事务 ID 的映射无法重新生成，因此客户端有责任重新启动事务。 其他有事务被失败的管理器写入的临时记录阻塞的客户端将不得不等待事务由于心跳超时而过期，然后才能正常进行。
