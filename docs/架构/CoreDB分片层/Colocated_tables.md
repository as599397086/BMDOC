AiSQL 支持共址 SQL 表。 这允许共址表中密切相关的数据一起驻留在称为“共址Tile”的单个父Tile中。 共址可减少跨网络的额外行程，有助于优化低延迟、高性能数据访问。 它还减少了为每个关系（表、索引等）创建Tile的开销以及每个节点的存储量。

请注意，共址Tile中的所有数据仍然根据集群的复制因子跨节点复制。

## **共址的好处以及用例的注意事项**

共址对于高性能、实时数据处理很有意义，其中低延迟和快速访问数据至关重要。共址具有以下优点：

* 改进的性能和可扩展性：使用单个tablet而不是为每个关系创建一个tablet可以减少存储和计算开销。
* 更快地访问数据：通过将单个数据库中多个表的所有数据存储在单个tablet中，您可以避免节点间通信和数据转移的开销，从而更快地访问数据。 例如，当跨多个共址表的数据位于本地并且您不再需要通过网络读取数据时，联接速度会提高。


**1.何时使用共址**
使用共址集群的决定应基于您的用例的具体要求，包括预期的性能、数据大小、可用性和持久性要求。 以下场景可能会受益于共址：
**（1）需要 HA 或地理分布的小型数据集**
具有较小数据集的应用程序可能具有以下模式和要求：

* 整个数据集的大小很小。 通常，整个数据库的大小小于 50 GB。
* 它们需要在单个数据库中创建大量表、索引和其他关系。
* 需要高可用性和/或地理数据分布。
* 扩展数据集或 IOPS 数量并不是迫在眉睫的问题。

在这种情况下，不希望将小数据集分布在多个节点上，因为这可能会由于更多的网络跃点（例如，联接）而影响某些查询的性能。

**（2）大型数据集 - 一些大表和许多小表**
具有大型数据集的应用程序可能具有以下特征：

* 大量的表和索引。
* 少数表预计会变大，因此需要进行扩展。
* 其余的表仍然很小。

这里只需要对少数大表进行分片和扩容。 所有其他表都受益于共址，因为涉及这些表的查询不需要网络跃点。

**（3）扩展数据库数量，每个数据库都有一个小数据集**
在某些场景下，集群中的数据库数量快速增长，而每个数据库的规模却很小。 这是面向微服务的架构的特征，其中每个微服务都需要自己的数据库。 一个例子是多租户 SaaS 服务，其中为每个客户创建一个数据库。 最终结果是出现大量小型数据库，并且需要扩展托管数据库的数量。 共址表允许将每个数据库中的整个数据集托管在一个Tile中，从而通过添加更多节点来实现集群中数据库数量的可扩展性。

将所有数据集中在一个Tile中需要一些权衡。 它可能会导致资源利用方面的潜在瓶颈。 最终，数据集的大小只是确定共址数据库是否适合您的用例时需要考虑的因素之一。

## **启用共址**

可以在集群、数据库或表级别启用共址。 对于共址集群，默认情况下，集群中创建的所有数据库都将启用共址。 您还可以选择将单个数据库配置为共址，以确保数据库表中的所有数据都存储在节点上的单个共址Tile上。 当进行实时数据处理或查询大量数据时，这尤其有用。

**1.集群**
要为集群中的所有数据库启用共址，请在创建集群时将 MServer 和 DBServer 服务的以下标志设置为 true，如下所示：

```
bsql_colocate_database_by_default = true
```

您也可以在创建集群后设置此标志，但需要重新启动 MServer 和 DBServer。

注意：对于 AiSQL Managed，您当前无法启用集群共址。 可为单个数据库启用共址。

**2.数据库**
您可以在非共址集群中创建共址数据库。 默认情况下，在此数据库中创建的表是共址的。 也就是说，数据库中的所有表共享一个tablet。 要启用此功能，请在创建数据库时运行以下命令：

```
CREATE DATABASE <name> with COLOCATION = true
```

对于支持共址的集群，您可以使用以下语法选择将特定数据库从共址中选择出来，设置不共址：

```
CREATE DATABASE <name> with COLOCATION = false
```

**3.表**
默认情况下，共址数据库中的所有表都是共址的。 创建表时无需启用共址。 您可以选择将特定表从共址数据库中的共址中选择出来，设置为不共址。 为此，请使用以下命令：

```
CREATE TABLE <name> (columns) WITH (COLOCATION = false);
```

请注意，您无法在非共址数据库中创建共址表。

**更改表共址**
要从共址中删除单个表（例如，如果它增加超过特定大小），您可以使用 CREATE TABLE AS SELECT 创建表的副本，并将共置设置为 false。 请执行下列操作：
（1）重命名您的共址表以确保不会有进一步的更改修改该表或其内容。
（2）使用 CREATE TABLE AS SELECT 从原始共址表创建新的非共址表。 您可以选择使用与原始表相同的名称。
（3）可选，在确认对新的非共址表进行读取和写入后，删除原始共址表。

您可以使用相同的过程将非共址表添加到共址数据库中的共址。

注：更改表共址需要在创建新表期间需要一些停机时间。 此过程所需的时间取决于共址更改的表的大小。

## **指标和视图**

要查看表大小等指标，请使用父共址表的名称。 共址表名称的格式为 <colocation table object ID>.colocation.parent.tablename。 共址中的所有表共享相同的指标值，这些值显示在每个指标的共址表下。 表和Tile指标可在 DBServer 端点 (<node-ip>:20000) 以及 AiSQL Anywhere 中每个 Universe 的“指标”部分中获得。

## **限制和注意事项**

不允许使用表空间创建共址表。 这将在未来的版本中得到支持。
表指标的指标（例如表大小）可用于共址Tile，而不适用于作为共址一部分的单个共址表。
对于共址表禁用Tile拆分。
您无法使用 2.18.0 版本中的 AiSQL Anywhere UI 为共址表配置 xDCR 复制。 此功能将在未来版本中提供。

**共址表和非共址表之间的语义差异**
同一共址数据库中不同表上的并发 DML 和 DDL， 将中止 DML。 对于分布式、非共址表来说，情况并非如此。 对于共址表，如果另一个会话持有表上的行级锁，则 TRUNCATE / DROP 操作可能会因冲突而中止。


## **xDCR和共址**

v2.18.0 中的共址表仅通过 bm-admin 支持 xDCR。 要为共址表设置 xDCR，给定表的共址 ID 需要在源 Universe 和目标 Universe 上匹配。

要为共址表设置 xDCR，请执行以下操作：

1.使用显式指定的共址 ID 在源 Universe 上的共址数据库中创建表。

```
CREATE TABLE <name> WITH (COLOCATION = true, COLOCATION_ID = 20000)
```

2.使用相同的共址 ID 在目标 Universe 上的共址数据库中创建表。

```
CREATE TABLE <name> WITH (COLOCATION = true, COLOCATION_ID = 20000)
```

3.获取共址数据库的父表 UUID。

```
./bm-admin -mserver_addresses <source_mserver_addresses> list_tables include_table_id | grep -i <database_name> | grep -i "colocation.parent.uuid"
col_db.00004000000030008000000000004004.colocation.parent.tablename 00004000000030008000000000004004.colocation.parent.uuid
```

4.使用 bm-admin 为父共址表设置复制。

```
./bm-admin -mserver_addresses <target_mserver_addresses> setup_universe_replication <replication_group_name> <source_mserver_addresses> <parent_colocated_table_uuid>
```

例如：

```
./bm-admin -mserver_addresses 127.0.0.2 setup_universe_replication A1-B2 127.0.0.1 00004000000030008000000000004004.colocation.parent.uuid
Replication setup successfully
```

如果将新的共址表添加到具有匹配共址 ID 的源和目标 Universe 上的同一共址数据库中，则它们会自动包含在复制中。

有关如何为非共址表设置 xDCR 的信息，请参阅 xDCR 部署。
