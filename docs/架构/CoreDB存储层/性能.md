CoreDB 使用 RocksDB 的定制版本，RocksDB 是一种基于日志结构合并树 (LSM) 的键值存储。

![](../../assets/chapter9/36.png)

##### **RocksDB 的增强**

对 RocksDB 进行的定制增强了可扩展性并提高了性能。

**1.高效的文档建模**
其中一项增强功能的目标是在键值存储之上实现灵活的数据模型，并在此数据模型上实现高效的操作，如下所示：

* 对行或集合的一部分进行细粒度更新，而不会导致整个行或集合的读取-修改-写入损失。
* 在任意嵌套级别删除或覆盖行、集合或对象，而不会产生读取惩罚以确定需要删除哪些特定的键值对集。
* 强制执行行级和对象级基于 TTL 的过期。

需要与底层 RocksDB 键值存储的读取层和压缩层进行更紧密的耦合。 RocksDB 用作仅追加存储，并且操作（例如行或集合删除）被建模为特殊删除标记的插入。 这允许通过向 RocksDB 添加一个键值对来有效地删除整个子文档。 读取hooks会自动识别这些标记并抑制过期数据。 子文档中的过期值将通过定制的压缩 hooks进行清理和垃圾收集。

**2.Raft 与 RocksDB WAL 日志**
CoreDB 使用 Raft 进行复制。 对分布式系统的更改已经记录或记录为 Raft 日志的一部分。 当大多数对等点接受更改时，它会应用于每个 Tablet 对等点的 CoreDB，但 RocksDB（在 CoreDB 下）中额外的预写日志记录 (WAL) 机制是不必要的，并且会增加开销。 为了确保正确性，除了禁用 RocksDB 中的 WAL 机制之外，AiSQL 还跟踪数据从 RocksDB 的 memtable 刷新到 SSTable 文件的 Raft 序列 ID。 这确保了 Raft WAL 日志可以被正确地垃圾收集。 它还允许在服务器崩溃或重新启动时重播 Raft WAL 日志中的最少数量的记录。

**3.更高层的MVCC**
CoreDB中的多版本并发控制（MVCC）是在更高层完成的，没有使用RocksDB的MVCC机制。

系统中记录的突变使用 YBase 层维护的混合时间戳进行版本控制。 因此，RocksDB 中使用序列 ID 实现的 MVCC 概念是不必要的，只会增加开销。 AiSQL不使用RocksDB的序列ID； 相反，它使用作为编码键一部分的混合时间戳来实现 MVCC。

**4.备份和快照**
备份和快照需要是更高级别的操作，考虑 CoreDB 以及 Raft 日志中的数据，以获得系统状态的一致剪切。

##### **数据模型感知的布隆过滤器**

RocksDB 中 CoreDB 存储的键由多个组件组成，其中第一个组件是文档键，后面是一些标量组件，最后是时间戳（按相反顺序排序）。

布隆过滤器需要知道应将键的哪些组件添加到布隆中，以便在读取操作期间仅搜索 LSM 存储中的相关 SSTable 文件。

在传统的键值存储中，范围扫描不使用布隆过滤器，因为落在范围内的确切键是未知的。 然而，实现了数据模型感知的布隆过滤器，其中共享相同哈希组件的键内的范围扫描也可以从布隆过滤器中受益。 例如，扫描以获取行中的所有列或集合的所有元素也可以受益于布隆过滤器。

##### **范围查询优化**

CoreDB 中复合键的有序（或范围）组件通常具有自然顺序。 例如，它可能是表示消息 ID（对于消息传递应用程序）或时间戳（对于 IoT 时间序列）的 int。 通过对 LSM 存储中的每个 SSTable 文件保留有关键的这些组件的最小值和最大值的提示，范围查询可以在读取操作期间智能地删除不相关 SSTable 文件的查找。

考虑以下示例：

```
SELECT message_txt
  FROM messages
WHERE user_id = 17
  AND message_id > 50
  AND message_id < 100;
```

以下示例说明了时间序列应用：

```
SELECT metric_value
  FROM metrics
WHERE metric_name = ’system.cpu’
  AND metric_timestamp < ?
  AND metric_timestamp > ?
```

##### **高效的内存使用**

在两种情况下，以服务器全局方式跨组件使用内存会带来好处。

**1.服务器全局块缓存**
共享块缓存用于 DBServer 托管的所有Tile的 CoreDB 和 RocksDB 实例。 这样可以最大限度地利用内存资源，并避免创建缓存孤岛，每个缓存孤岛都需要针对不同的用户表准确调整大小。

**2.服务器全局内存存储限制**
虽然可以配置每个内存存储的刷新大小，但实际上，由于当用户创建新表或在服务器之间移动表的Tile时，内存存储的数量可能会随着时间而变化，因此增强了存储引擎以强制执行全局内存存储阈值。 当达到这样的阈值时，选择要刷新的内存存储会考虑哪些内存存储携带最旧的记录（由混合时间戳确定），因此会保留 Raft 日志并防止它们被垃圾收集。

##### **抗扫描块缓存**

CoreDB 增强了 RocksDB 的块缓存，使其具有抗扫描能力。 其动机是防止长时间运行的扫描（例如，由于偶尔的大型查询或后台 Spark 作业）等操作用质量较差的数据污染整个缓存并擦除有用的数据。
