## **BSQL**

### **使用应用程序模式**

在多个数据中心中运行应用程序并在这些数据中心之间拆分数据，这不是一项微不足道的任务。在设计全局应用程序时，请从一套经过实战测试的设计模式中为您的应用程序选择合适的设计模式，包括全局数据库、多主、备用集群、重复索引等。您也可以根据需要组合这些模式。


### **共址**

共址表通过减少小型表在网络上的额外访问来优化数据访问的延迟和性能。此外，它还减少了为每个关系（表、索引等）及其每个节点的存储创建分片的开销。 


### **使用覆盖索引加快读取速度**

当查询使用索引更快地查找行时，索引中不存在的列将从原始表中提取。这导致到主表的额外往返行程，导致延迟增加。
使用覆盖索引将查询所需的所有列存储在索引中，索引将标准索引扫描转换为仅索引扫描。

### **使用部分索引加快写入速度**

部分索引是建立在表的子集上的索引，只包括满足WHERE子句中指定条件的行。这加快了对表的任何写入并减小了索引的大小，从而提高了使用索引的读取查询的速度。

### **具有唯一索引的不同键**

如果需要某些列中的值是唯一的，可以将索引指定为unique。

将唯一索引应用于两列或多列时，这些列中的组合值不能在多行中重复。请注意，因为NULL值被视为不同的值，所以在具有唯一索引的列中可以有多个NULL值。 

### **具有服务器级缓存的快序列**

数据库中的序列会自动生成递增的数字，非常适合生成唯一的值，如订单号、用户ID、支票号等。它们可以防止多个应用程序实例同时生成重复的值。但是，在跨区域的数据库上生成序列可能会对应用程序产生延迟影响。
启用服务器级缓存以提高序列的速度，同时避免在应用程序断开连接时丢弃许多序列值。

### **快速单行事务**

更新行和在多个语句中获取结果的常见场景可能会导致应用程序和服务器之间的多次往返。在许多情况下，使用RETURNING子句将这些语句重写为单个语句将降低延迟，因为BMDB进行了优化，使单个语句更快。例如，以下语句： 

```
SELECT v FROM txndemo WHERE k=1 FOR UPDATE;
UPDATE txndemo SET v = v + 3 WHERE k=1;
SELECT v FROM txndemo WHERE k=1;
```

可以如下重写：

```
UPDATE txndemo SET v = v + 3 WHERE k=1 RETURNING v;
```

### **使用分区快速删除旧数据**

使用表分区可以根据日期将数据拆分为多个分区，这样您就可以通过删除分区来快速删除较旧的数据。

### **为分区键使用正确的数据类型**

通常，整数、任意精度的数字、字符串（不是很长的字符串）和时间戳类型是比较的安全选择。
避免以下情况：

浮点数字数据类型-因为它们以二进制浮点格式存储，无法精确表示大多数十进制值，所以可能存在多个内部表示，因此假定相同的值可能不会被视为匹配。

日期、时间和类似的时间戳组件类型，如果它们可以与来自不同时区或一年中不同日期的值进行比较，或者其中一个值来自观测或曾经观测到夏令时的国家或地区

### **尽可能使用多行插入**

如果要插入多行，则尽可能将它们批处理在一起会更快。您可以从每个批次128行开始，测试不同的批次大小以找到最佳点。

不要使用多个语句：

```
INSERT INTO users(name,surname) VALUES ('bill', 'jane');
INSERT INTO users(name,surname) VALUES ('billy', 'bob');
INSERT INTO users(name,surname) VALUES ('joey', 'does');
```

相反，将值分组为一条语句，如下所示：

```
INSERT INTO users(name,surname) VALUES ('bill', 'jane'), ('billy', 'bob'), ('joe', 'does');
```

### **UPSERT 尽可能的多行**

PostgreSQL和BSQL使您能够使用INSERT ON CONFLICT子句进行upserts 。与多行插入类似，您也可以在单个INSERT ON CONFLICT语句中批处理多个追加，以获得更好的性能。

如果该行已经存在，则可以使用EXCLUDED访问现有值<column_name>。

以下示例创建一个表来跟踪产品数量，并批量增加行数：

```
CREATE TABLE products
  (
     name     TEXT PRIMARY KEY,
     quantity BIGINT DEFAULT 0
  );
---
INSERT INTO products(name, quantity)
VALUES
  ('apples', 1),
  ('oranges', 5) ON CONFLICT(name) DO UPDATE
SET
  quantity = products.quantity + excluded.quantity;
---
INSERT INTO products(name, quantity)
VALUES
  ('apples', 1),
  ('oranges', 5) ON CONFLICT(name) DO UPDATE
SET
  quantity = products.quantity + excluded.quantity;
---
SELECT * FROM products;
  name   | quantity
---------+----------
 apples  |        2
 oranges |       10
(2 rows)
```

Load balance and failover using smart drivers

### **使用智能驱动程序实现负载平衡和故障切换**

BMDB智能驱动程序提供高级的集群感知负载平衡功能，使您的应用程序只需连接到一个节点即可向集群中的多个节点发送请求。您还可以通过为特定区域分配优先级并确保连接到具有最高优先级的区域来设置回退层次结构，然后在高优先级区域出现故障时回退到具有下一优先级的区域。

### **使用连接池扩展应用程序**

使用HikariCP 和Tomcat等流行的池化解决方案以及BMDB智能驱动程序，根据应用程序的扩展需要，使用不同的负载平衡策略设置不同的池。

### **使用BSQL连接管理器**

BMDB包括一个内置的连接池程序BSQL connection Manager TP，它提供了与其他外部池解决方案相同的连接池优势，但没有许多限制。由于管理器与产品捆绑在一起，因此可以方便地管理、监视和配置服务器连接。 

### **重复使用预编译语句的查询计划**

只要可能，使用预编译语句来确保BMDB可以重复使用相同的查询计划，并消除服务器在每次操作中解析查询的需要。 

### **大型扫描和批处理作业**

对于批处理或长时间运行的作业，请使用BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE READ ONLY DEFERRABLE，这些作业需要数据库的一致快照，而不会受到其他事务的干扰。 

### **JSONB数据类型**

使用JSONB数据类型对JSON数据进行建模；也就是说，没有设置模式但具有真正动态模式的数据。
BSQL中的JSONB与PostgreSQL中的JSONB数据类型相同。
您可以使用JSONB对表中不太感兴趣或访问频率较低的列进行分组。
BSQL还支持JSONB表达式索引，该索引可用于加快数据检索，否则将需要扫描JSON条目。

注：
仅在必要时使用JSONB列
一个好的模式设计是只将JSONB用于真正的动态模式。也就是说，不要在放置所有内容的地方创建“data JSONB”列；相反，为动态数据创建一个JSONB列，并为其他数据使用常规列。
与普通列相比，JSONB列的读/写速度较慢。
JSONB值占用更多的空间，因为它们需要将键存储在字符串中，而且维护数据一致性更困难，需要更复杂的查询来获取/设置JSONB的值。
当写入是作为具有每行层次结构的整个文档来完成时，JSONB非常适合。如果有数组，那么选择不是JSONB与列，而是与其他关系表。
对于读取，如果您读取整个文档，并且搜索到的表达式已编入索引，那么JSONB非常适合。
当频繁读取一个属性时，最好将其移动到列中，因为它可以包含在仅索引扫描的索引中。 

### **跨分片并行**

对于必须扫描所有分片的大型或批量SELECT或DELETE，您可以通过使用bm_hash_code函数创建仅影响分片特定部分的查询来并行化操作。 

### **单一可用性区域（AZ）部署**

在单个AZ部署中，需要将bm-dbserver标志--durable_wal_write=true设置为在整个数据中心出现故障（例如电源故障）时不会丢失数据。

### **行大小限制**

当您选择整行或多行时，大列会相加。为了保持一致的延迟或性能，建议将大小保持在10MB或以下，最大32MB。

### **列大小限制**

为了保持一致的延迟或性能，建议将列的大小设置在2MB或更小的范围内，即使支持单个列或行限制到32MB。

### **TRUNCATE表而不是DELETE**

TRUNCATE 删除存储表的数据库文件，速度比DELETE快得多，DELETE为事务中的每一行插入一个删除标记，这些事务稍后在压缩运行期间从存储中删除。 

### **表和索引的数量**

每个表和索引都被拆分为多个分片，每个分片都有开销。

### **每台服务器的分片**

每个表和索引都由几个基于--bsql_num_shards_per_dbserver标志的分片组成。
对于带有RF3的集群，1000个分片的raft心跳开销为0.4vCPU（假设心跳间隔为0.5秒），300MB内存，128GB磁盘空间用于WAL（预写日志）。

您需要记住这个数字，这取决于您打算创建的每台服务器的表数和分片数。请注意，每个分片可以包含100GB+的数据。 

您可以尝试以下方法之一来减少分片的数量：

* 使用共址将小表分组为一个分片。
* 使用--bsql_num_shards_per_dbserver标志减少每个表的分片数量。
* 创建表时使用SPLIT INTO子句。
* 从少量分片开始，使用自动拆分分片 

### **CI和CD集成测试的设置**

您可以在CI和CD自动测试场景中使用BMDB设置某些标志以提高性能，如下所示： 

* 将标志--fs_data_dirs和--fs_wal_dirs指向RAMDisk目录，以加快DML、DDL、集群创建和集群删除的速度，确保数据不会写入磁盘。 

* 设置标志--bm_num_shards_per_dbserver=1。减少分片数量可以降低创建或删除BSQL表以及写入或读取少量数据时的开销。 

* 在BSQL中使用共址数据库。在创建或删除BSQL表以及写入或读取少量数据时，共址降低了开销。

* 为测试场景设置标志--replication_factor=1，因为不需要保持数据的三向复制（默认）。将其减少到1可减少空间使用并提高性能。 

* 使用TRUNCATE table1,table2,table3..tablen;而不是CREATE TABLE和DROP TABLE。 

 

## **BCQL**

### **全局二级索引**

索引使用BMDB的多分片事务功能，具有全局性和强一致性（ACID）。要添加辅助索引，您需要创建启用了事务的表。通过使用INCLUDE 子句，它们也可以用作物化视图。

### **唯一索引**

BCQL支持唯一索引。唯一索引不允许在索引列中插入重复值 

### **覆盖索引**

当通过辅助索引进行查询时，会查阅原始表以获取索引中未指定的列。这可能导致在主表上进行多次随机读取。

有时，更好的方法是使用include子句包括您正在查询的不属于索引的其他列。当索引中包含其他列时，它们可以用于直接响应索引中的查询，而不必查询表。


这将从主表中（可能的）随机读取变成索引上的过滤。 

### **使用UPDATE IF EXISTS的原子读-修改-写操作**

对于UPDATE ... IF EXISTS 和INSERT ... IF NOT EXISTS操作，需要原子读-修改-写的情况，Apache Cassandra使用LWT，它需要在对等端之间进行4次往返。由于BMDB的CP（在CAP定理中）设计基于强一致性，这些操作在BMDB中得到了更有效的支持，并且只需要在对等点之间进行一次Raft往返。数字和计数器类型工作相同，不需要单独的“计数器”表。

### **JSONB**

BMDB支持jsonb数据类型来对JSON数据进行建模，JSON数据没有设置模式，可能会经常更改。您可以使用JSONB对表中访问较少的列进行分组。BCQL还支持JSONB表达式索引，这些索引可用于加快数据检索，否则将需要扫描JSON条目。

注：
仅在必要时使用JSONB列
与普通列相比，jsonb列的读写速度较慢。它们还占用了更多的空间，因为它们需要将Key存储在字符串中，并使保持数据一致性变得更加困难。一个好的模式设计是将大多数列保留为常规列或集合，并且只对真正的动态值使用jsonb。不要在存储所有内容的地方创建数据jsonb列；相反，使用dynamic_data jsonb列，其他列为基元列。 

### **递增和递减数字类型**

在BMDB中，BCQL扩展了Apache Cassandra，为整数数据类型添加了递增和递减运算符。整数可以设置、插入、递增和递减，而COUNTER只能递增或递减。BMDB在一次往返中实现CAS（比较和设置）操作，而Apache Cassandra需要四次往返。

### **使用TTL自动使旧记录过期**

BCQL支持使用TTL功能的数据自动过期。您可以为表/行/列级别的数据设置保留策略，旧数据将自动从数据库中清除。
如果为时间序列数据集或任何具有表级TTL的数据集配置TTL，建议使用TTL特定的配置选项直接使旧文件过期，以提高CPU和空间效率。

### **使用BMDB驱动程序**

使用BMDB特定的客户端驱动程序，因为它们支持集群和分区，并支持jsonb列。

### **利用BCQL客户端中的连接池**

理想情况下，单个客户端（例如，多线程应用程序）应该使用单个集群对象。单个集群对象通常在底层包含可配置数量的到BM - dbserver的连接。通常，每个BM - dbserver 1或2个连接足以服务64-128个应用程序线程。同一连接可以用于多个未完成的请求，也称为多路复用。

### **使用预编译语句**

只要可能，使用预编译语句来确保BMDB分区感知驱动程序可以将查询路由到分片leader，以提高吞吐量，并消除服务器在每次操作中解析查询的需要。

### **使用批处理提高吞吐量**

使用批处理来编写一组操作，以便在单个RPC调用中发送所有操作，而不是使用多个RPC调用，每个操作一个。与单行操作相比，每个批处理操作具有更高的延迟，但总体吞吐量更高。

### **列和行大小**

为了获得一致的延迟/性能，请将列保持在2 MB或更小的范围内。
选择多列或整行时，大列相加。为了获得一致的延迟和性能，请将单个行的大小保持在32 MB或更小的范围内。

### **不要使用大型集合**

集合用于存储不希望增长到任意大小的小集合（例如用户的电话号码或地址，而不是帖子或消息）。虽然允许较大的集合，但它们可能会对涉及它们的查询的性能产生重大影响。特别是，某些列表操作（在索引处插入并移除元素）需要先读后写 

### **具有许多元素的集合**

集合中的每个元素最终在CoreDB中作为一个单独的键值，增加了每个元素的开销。

如果您的集合是不可变的，或者您完全更新了整个集合，请考虑使用JSONB数据类型。另一种选择是使用ProtoBuf 或FlatBuffers ，并将序列化的数据存储在BLOB列中。 

### **将partition_hash用于大型表扫描**

partition_hash函数可用于查询数据的子集，以获得近似的行计数，或将全表操作分解为可以并行运行的较小子任务。

### **TRUNCATE表而不是DELETE**

TRUNCATE删除存储表的数据库文件，速度比DELETE快得多，DELETE为事务中的每一行插入一个删除标记，并在压缩运行时将其从存储中删除。 
